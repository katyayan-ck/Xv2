-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.

Folder : d:\xampp\htdocs\vdms\app\.\Console

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Console

Folder : d:\xampp\htdocs\vdms\app\.\Console\Commands

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Console\Commands

File : ExportUsersCommand.php
/////////Content of file ExportUsersCommand.php
<?php

namespace App\Console\Commands;

use App\Services\Exporters\UserExporter;
use Exception;
use Illuminate\Console\Command;

class ExportUsersCommand extends Command
{
    protected $signature = 'export:users 
                          {--branch= : Export only users from specific branch code}
                          {--department= : Export only users from specific department code}
                          {--designation= : Export only users with specific designation code}
                          {--status=active : Filter by status (active|inactive|all)}
                          {--output= : Output file path (default: storage/exports/)}';

    protected $description = 'Export users to Excel file with assignments and data scopes';

    public function __construct()
    {
        parent::__construct();
    }

    public function handle()
    {
        try {
            $this->info('==========================================================');
            $this->info('      VDMS USER EXPORT SYSTEM');
            $this->info('==========================================================');
            $this->info('');

            // Build filters
            $filters = [];

            if ($this->option('branch')) {
                $this->info('Filter: Branch = ' . $this->option('branch'));
                $filters['branch_code'] = $this->option('branch');
            }

            if ($this->option('department')) {
                $this->info('Filter: Department = ' . $this->option('department'));
                $filters['department_code'] = $this->option('department');
            }

            if ($this->option('designation')) {
                $this->info('Filter: Designation = ' . $this->option('designation'));
                $filters['designation_code'] = $this->option('designation');
            }

            $status = $this->option('status');
            if ($status !== 'all') {
                $this->info('Filter: Status = ' . ucfirst($status));
                $filters['is_active'] = ($status === 'active');
            }

            $this->info('');
            $progressBar = $this->output->createProgressBar(100);
            $progressBar->setFormat('Progress: [%bar%] %percent%% - %message%');
            $progressBar->start();

            // Determine output path
            $outputPath = $this->option('output');
            if (!$outputPath) {
                $outputPath = storage_path('exports/users_' . date('Y-m-d-His') . '.xlsx');
            }

            // Ensure directory exists
            @mkdir(dirname($outputPath), 0755, true);

            $progressBar->advance(20);
            $progressBar->setMessage('Preparing export...');

            // Create exporter
            $exporter = new UserExporter($outputPath);
            $exporter->withFilters($filters);

            $progressBar->advance(30);
            $progressBar->setMessage('Generating sheets...');

            // Execute export
            $result = $exporter->execute();

            $progressBar->advance(40);
            $progressBar->setMessage('Finalizing...');
            $progressBar->finish();

            $this->info('');
            $this->info('');

            // Results
            if ($result['success']) {
                $this->table(
                    ['Metric', 'Value'],
                    [
                        ['Total Exported', $result['count']],
                        ['File Path', $result['path']],
                        ['File Size', number_format(filesize($result['path']) / 1024, 2) . ' KB'],
                        ['Status', 'âœ“ SUCCESS'],
                    ]
                );

                $this->info('');
                $this->info('Export Details:');
                $this->info('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
                $this->info('âœ“ Users Sheet: Main user data');
                $this->info('âœ“ Assignments Sheet: Branch, Department, Location, Post assignments');
                $this->info('âœ“ Data Scopes Sheet: RBAC data scoping information');
                $this->info('âœ“ Summary Sheet: Statistics and distribution by branch');

                $this->info('');
                $this->info('File ready for download: ' . basename($result['path']));
                $this->info('');

                return 0;
            } else {
                $this->error('Export failed: ' . $result['message']);
                return 1;
            }
        } catch (Exception $e) {
            $this->error('');
            $this->error('EXPORT FAILED');
            $this->error('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
            $this->error('Error: ' . $e->getMessage());
            $this->error('');

            if ($this->option('verbose')) {
                $this->error($e->getTraceAsString());
            }

            return 1;
        }
    }
}
///////End-of-File : ExportUsersCommand.php

File : ExportVehicleData.php
/////////Content of file ExportVehicleData.php
<?php

namespace App\Console\Commands;

use App\Exports\VehicleDataExport;
use Illuminate\Console\Command;
use Maatwebsite\Excel\Facades\Excel;

class ExportVehicleData extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'export:vehicle-data {--path=}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Export all vehicle data to Excel file';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        try {
            // Generate filename with timestamp
            $timestamp = now()->format('d-m-Y-H-i-s');
            $filename = "VehicleDataExport_{$timestamp}.xlsx";

            // Determine export directory
            if ($this->option('path')) {
                // Custom path provided
                $exportDir = $this->option('path');
            } else {
                // Default: public/exports
                $exportDir = public_path('exports');
            }

            // Normalize path
            $exportDir = str_replace(['\\', '/'], DIRECTORY_SEPARATOR, $exportDir);
            $exportDir = rtrim($exportDir, DIRECTORY_SEPARATOR);

            // Create directory if needed
            if (!is_dir($exportDir)) {
                if (!@mkdir($exportDir, 0755, true)) {
                    throw new \Exception("Cannot create directory: {$exportDir}");
                }
            }

            if (!is_writable($exportDir)) {
                throw new \Exception("Directory not writable: {$exportDir}");
            }

            $fullPath = $exportDir . DIRECTORY_SEPARATOR . $filename;

            $this->info("\nðŸ“Š Starting Vehicle Data Export...\n");
            $this->info("ðŸ“ Export Directory: {$exportDir}\n");
            $this->info("ðŸ“„ Filename: {$filename}\n");

            // Use temp file in public folder
            $tempPath = public_path('exports' . DIRECTORY_SEPARATOR . '.temp_' . $filename);

            // Export to temp file using Maatwebsite
            Excel::store(
                new VehicleDataExport(),
                '.temp_' . $filename,
                'public/exports'
            );

            // Check if temp file exists in the expected location
            if (!file_exists($tempPath)) {
                // Try alternative: write to temp directory and copy
                $sysTemp = sys_get_temp_dir() . DIRECTORY_SEPARATOR . $filename;

                Excel::store(
                    new VehicleDataExport(),
                    $sysTemp
                );

                if (!file_exists($sysTemp)) {
                    throw new \Exception("Export file creation failed");
                }

                // Copy from temp to final location
                if (!@copy($sysTemp, $fullPath)) {
                    throw new \Exception("Failed to copy file to {$fullPath}");
                }

                @unlink($sysTemp);
            } else {
                // Rename temp to final
                if (!@rename($tempPath, $fullPath)) {
                    if (!@copy($tempPath, $fullPath)) {
                        throw new \Exception("Failed to finalize export file");
                    }
                    @unlink($tempPath);
                }
            }

            // Verify file was created
            if (!file_exists($fullPath)) {
                throw new \Exception("File creation failed: {$fullPath}");
            }

            $fileSize = filesize($fullPath);
            $fileSizeKB = round($fileSize / 1024, 2);
            $webUrl = url('exports/' . $filename);

            $this->info("âœ… Export completed successfully!\n");
            $this->info("ðŸ“ Full Path: {$fullPath}\n");
            $this->info("ðŸ“¦ Size: {$fileSizeKB} KB\n");
            $this->info("ðŸŒ Web URL: {$webUrl}\n");
            $this->info("â° Timestamp: {$timestamp}\n");

            return 0;
        } catch (\Exception $e) {
            $this->error("\nâŒ Export failed:\n");
            $this->error($e->getMessage() . "\n");
            return 1;
        }
    }
}
///////End-of-File : ExportVehicleData.php

File : ImportRulesUsersCommand.php
/////////Content of file ImportRulesUsersCommand.php
<?php

namespace App\Console\Commands;

use App\Services\Importers\RulesUserImporter;
use Exception;
use Illuminate\Console\Command;

class ImportRulesUsersCommand extends Command
{
    protected $signature = 'import:rules-users 
                          {file : Path to Excel file to import}
                          {--sheet=UserList : Sheet name to import from (default: "User List")}
                          {--dry-run : Show what would be imported without saving}';

    protected $description = 'Import users from Rules.xlsx format with smart data handling';

    public function handle()
    {
        $filePath = $this->argument('file');
        $sheetName = $this->option('sheet');
        $dryRun = $this->option('dry-run');

        // Validate file exists
        if (!file_exists($filePath)) {
            $this->error("âŒ File not found: $filePath");
            return 1;
        }

        // Validate file is Excel
        $ext = pathinfo($filePath, PATHINFO_EXTENSION);
        if (!in_array(strtolower($ext), ['xlsx', 'xls'])) {
            $this->error("âŒ Invalid file type. Expected .xlsx or .xls");
            return 1;
        }

        try {
            $this->info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            $this->info('      RULES USER IMPORT SYSTEM');
            $this->info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            $this->info('');

            if ($dryRun) {
                $this->warn('âš ï¸  DRY RUN MODE - No data will be saved');
                $this->info('');
            }

            $this->info('File Details:');
            $this->info("  Path: " . basename($filePath));
            $this->info("  Size: " . number_format(filesize($filePath) / 1024, 2) . " KB");
            $this->info("  Sheet: '{$sheetName}'");
            $this->info('');

            // Start import
            $this->info('Starting import process...');

            $progressBar = $this->output->createProgressBar(100);
            $progressBar->setFormat('Progress: [%bar%] %percent%% (%current%/%max%) - %message%');
            $progressBar->setMessage('Reading file...');
            $progressBar->start();

            $importer = new RulesUserImporter($filePath, $sheetName);
            $progressBar->advance(40);
            $progressBar->setMessage('Processing users...');

            $result = $importer->execute();

            $progressBar->advance(50);
            $progressBar->setMessage('Finalizing...');
            $progressBar->finish();

            $this->info('');
            $this->info('');

            // Results Table
            $this->table(
                ['Metric', 'Count'],
                [
                    ['Total Processed', $result['total_processed']],
                    ['âœ“ Imported (New)', $result['imported']],
                    ['â†» Updated (Existing)', $result['updated']],
                    ['âŠ˜ Skipped', $result['skipped']],
                    ['âš  Errors', count($result['errors'])],
                    ['Duration', $result['duration_seconds'] . 's'],
                    ['Status', $result['success'] ? 'âœ“ SUCCESS' : 'âœ— FAILED'],
                ]
            );

            // Detailed Results
            $this->info('');
            $this->info('Result Summary:');
            $this->info('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

            if ($result['imported'] > 0) {
                $this->line("  <fg=green>âœ“ New Users Created: {$result['imported']}</>");
            }

            if ($result['updated'] > 0) {
                $this->line("  <fg=blue>â†» Existing Users Updated: {$result['updated']}</>");
            }

            if ($result['skipped'] > 0) {
                $this->line("  <fg=yellow>âŠ˜ Records Skipped: {$result['skipped']}</>");
            }

            // Errors
            if (!empty($result['errors'])) {
                $this->error('');
                $this->error('ERRORS ENCOUNTERED:');
                $this->error('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

                foreach ($result['errors'] as $error) {
                    $this->error("Row {$error['row']}: {$error['error']}");
                }
            }

            // Warnings
            if (!empty($result['warnings'])) {
                $this->warn('');
                $this->warn('WARNINGS:');
                $this->warn('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

                foreach ($result['warnings'] as $warning) {
                    $this->warn($warning);
                }
            }

            $this->info('');
            $this->info($result['message']);
            $this->info('');

            return $result['success'] ? 0 : 1;
        } catch (Exception $e) {
            $this->error('');
            $this->error('âŒ IMPORT FAILED');
            $this->error('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
            $this->error('Error: ' . $e->getMessage());
            $this->error('');

            if ($this->option('verbose')) {
                $this->error($e->getTraceAsString());
            }

            return 1;
        }
    }
}
///////End-of-File : ImportRulesUsersCommand.php

File : ImportUsersCommand.php
/////////Content of file ImportUsersCommand.php
<?php

namespace App\Console\Commands;

use App\Services\Importers\UserImporter;
use Exception;
use Illuminate\Console\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;

class ImportUsersCommand extends Command
{
    protected $signature = 'import:users {file : Path to Excel file to import}
                          {--branch= : Filter by branch code}
                          {--department= : Filter by department code}
                          {--role= : Assign role to all imported users}
                          {--skip-validation : Skip field validation}
                          {--dry-run : Show what would be imported without saving}';

    protected $description = 'Import users from Excel file (Person â†’ Employee â†’ User hierarchy)';

    public function __construct()
    {
        parent::__construct();
    }

    public function handle()
    {
        $filePath = $this->argument('file');

        // Validate file exists
        if (!file_exists($filePath)) {
            $this->error("File not found: $filePath");
            return 1;
        }

        // Validate file is Excel
        $ext = pathinfo($filePath, PATHINFO_EXTENSION);
        if (!in_array(strtolower($ext), ['xlsx', 'xls', 'csv'])) {
            $this->error("Invalid file type. Expected .xlsx, .xls, or .csv");
            return 1;
        }

        try {
            $this->info('==========================================================');
            $this->info('      VDMS USER IMPORT SYSTEM');
            $this->info('==========================================================');
            $this->info('');
            $this->info('File: ' . basename($filePath));
            $this->info('Size: ' . number_format(filesize($filePath) / 1024, 2) . ' KB');
            $this->info('');

            // Start import
            $this->info('Starting import process...');
            $this->info('');

            $progressBar = $this->output->createProgressBar(100);
            $progressBar->setFormat('Progress: [%bar%] %percent%% - %message%');
            $progressBar->setMessage('Reading file...');
            $progressBar->start();

            $importer = new UserImporter($filePath);
            $progressBar->advance(30);
            $progressBar->setMessage('Validating records...');

            $progressBar->advance(20);
            $progressBar->setMessage('Processing imports...');

            $result = $importer->execute();

            $progressBar->advance(40);
            $progressBar->setMessage('Finalizing...');
            $progressBar->finish();

            $this->info('');
            $this->info('');

            // Results
            $this->table(
                ['Metric', 'Value'],
                [
                    ['Total Imported', $result['imported']],
                    ['Skipped', $result['skipped']],
                    ['Total Processed', $result['imported'] + $result['skipped']],
                    ['Status', $result['success'] ? 'âœ“ SUCCESS' : 'âœ— FAILED'],
                ]
            );

            // Errors
            if (!empty($result['errors'])) {
                $this->error('');
                $this->error('ERRORS ENCOUNTERED:');
                $this->error('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

                foreach ($result['errors'] as $error) {
                    $this->error("Row {$error['row']}: {$error['error']}");
                }
            }

            // Warnings
            if (!empty($result['warnings'])) {
                $this->warn('');
                $this->warn('WARNINGS:');
                $this->warn('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

                foreach ($result['warnings'] as $warning) {
                    $this->warn($warning);
                }
            }

            $this->info('');
            $this->info($result['message']);
            $this->info('');

            return $result['success'] ? 0 : 1;
        } catch (Exception $e) {
            $this->error('');
            $this->error('IMPORT FAILED');
            $this->error('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
            $this->error('Error: ' . $e->getMessage());
            $this->error('');

            if ($this->option('verbose')) {
                $this->error($e->getTraceAsString());
            }

            return 1;
        }
    }
}
///////End-of-File : ImportUsersCommand.php

File : ImportVehicleDefine.php
/////////Content of file ImportVehicleDefine.php
<?php

namespace App\Console\Commands;

use App\Imports\VehicleDefineImporter;
use Illuminate\Console\Command;
use Maatwebsite\Excel\Facades\Excel;

class ImportVehicleDefine extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'import:vehicle-define
                            {--file= : Path to the Excel file to import}
                            {--force : Force import without confirmation}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Import vehicle definitions from Excel file (Brand â†’ Segment â†’ SubSegment â†’ VehicleModel â†’ Variant + Colors)';

    /**
     * Execute the console command.
     */
    public function handle()
    {
        $file = $this->option('file');

        if (!$file) {
            $this->error('File path is required. Use: php artisan import:vehicle-define --file=/path/to/file.xlsx');
            return Command::FAILURE;
        }

        if (!file_exists($file)) {
            $this->error("File not found: {$file}");
            return Command::FAILURE;
        }

        if (!$this->option('force')) {
            $this->warn('This will import vehicle data. Make sure you have a backup of your database.');
            if (!$this->confirm('Do you want to continue?')) {
                $this->info('Import cancelled.');
                return Command::FAILURE;
            }
        }

        try {
            $this->info("Starting import from: {$file}");
            $this->newLine();

            Excel::import(new VehicleDefineImporter(), $file);

            $this->info('âœ“ Import completed successfully!');
            $this->newLine();
            $this->line('Check storage/logs/laravel.log for detailed import logs.');

            return Command::SUCCESS;
        } catch (\Exception $e) {
            $this->error("Import failed: {$e->getMessage()}");
            \Log::error("Vehicle import error: {$e->getMessage()}", [
                'file' => $file,
                'trace' => $e->getTraceAsString(),
            ]);
            return Command::FAILURE;
        }
    }
}
///////End-of-File : ImportVehicleDefine.php

File : s
/////////Content of file s
///////End-of-File : s

Folder : d:\xampp\htdocs\vdms\app\.\Exceptions

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Exceptions

File : PermissionException.php
/////////Content of file PermissionException.php
<?php

namespace App\Exceptions;

use Exception;
use Illuminate\Http\JsonResponse;

class PermissionException extends Exception
{
    protected $code = 'E_PERMISSION';
    protected $httpStatus = 403;

    public function __construct(
        string $message = '',
        string $code = 'E_PERMISSION',
        int $httpStatus = 403,
        ?Exception $previous = null
    ) {
        $this->code = $code;
        $this->httpStatus = $httpStatus;
        parent::__construct($message, 0, $previous);
    }

    public function render(): JsonResponse
    {
        return response()->json([
            'http_status' => $this->httpStatus,
            'success' => false,
            'code' => $this->code,
            'message' => $this->message,
        ], $this->httpStatus);
    }
}
///////End-of-File : PermissionException.php

File : v
/////////Content of file v
///////End-of-File : v

File : ValidationException.php
/////////Content of file ValidationException.php
<?php

namespace App\Exceptions;

use Exception;
use Illuminate\Http\JsonResponse;

class ValidationException extends Exception
{
    protected $code = 'E_VALIDATION';
    protected $httpStatus = 422;
    protected $errors = [];

    public function __construct(
        string $message = '',
        array $errors = [],
        string $code = 'E_VALIDATION',
        int $httpStatus = 422
    ) {
        $this->code = $code;
        $this->httpStatus = $httpStatus;
        $this->errors = $errors;
        parent::__construct($message);
    }

    public function render(): JsonResponse
    {
        return response()->json([
            'http_status' => $this->httpStatus,
            'success' => false,
            'code' => $this->code,
            'message' => $this->message,
            'errors' => $this->errors,
        ], $this->httpStatus);
    }
}
///////End-of-File : ValidationException.php

Folder : d:\xampp\htdocs\vdms\app\.\Exports

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Exports

File : e
/////////Content of file e
///////End-of-File : e

File : UserExporter.php
/////////Content of file UserExporter.php
<?php

namespace App\Services\Exporters;

use App\Models\User;
use App\Models\Core\Employee;
use Carbon\Carbon;
use Exception;
use Illuminate\Support\Facades\Log;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;
use PhpOffice\PhpSpreadsheet\Style\Font;
use PhpOffice\PhpSpreadsheet\Style\Fill;
use PhpOffice\PhpSpreadsheet\Style\Alignment;

/**
 * UserExporter Service
 * 
 * Handles bulk export of users to Excel files
 * Exports Person, Employee, User, and all assignment data
 * Includes RBAC and data scoping information
 */
class UserExporter
{
    private $filters = [];
    private $outputPath;

    public function __construct($outputPath = null)
    {
        $this->outputPath = $outputPath ?? storage_path('exports/users_' . date('Y-m-d-His') . '.xlsx');
    }

    /**
     * Set filters for export
     */
    public function withFilters($filters)
    {
        $this->filters = $filters;
        return $this;
    }

    /**
     * Filter by branch
     */
    public function filterByBranch($branchId)
    {
        $this->filters['branch_id'] = $branchId;
        return $this;
    }

    /**
     * Filter by department
     */
    public function filterByDepartment($departmentId)
    {
        $this->filters['department_id'] = $departmentId;
        return $this;
    }

    /**
     * Filter by designation
     */
    public function filterByDesignation($designationId)
    {
        $this->filters['designation_id'] = $designationId;
        return $this;
    }

    /**
     * Filter by status
     */
    public function filterByStatus($isActive)
    {
        $this->filters['is_active'] = $isActive;
        return $this;
    }

    /**
     * Execute the export process
     */
    public function execute()
    {
        try {
            $spreadsheet = new Spreadsheet();

            // Get users based on filters
            $users = $this->getFilteredUsers();

            // Create main users sheet
            $this->createUsersSheet($spreadsheet, $users);

            // Create summary sheet
            $this->createSummarySheet($spreadsheet, $users);

            // Create assignments sheet
            $this->createAssignmentsSheet($spreadsheet, $users);

            // Create data scopes sheet
            $this->createDataScopesSheet($spreadsheet, $users);

            // Save file
            $writer = new Xlsx($spreadsheet);
            $writer->save($this->outputPath);

            return [
                'success' => true,
                'path' => $this->outputPath,
                'filename' => basename($this->outputPath),
                'count' => $users->count(),
                'message' => sprintf('Exported %d users to %s', $users->count(), basename($this->outputPath)),
            ];
        } catch (Exception $e) {
            Log::error('User Export Failed', ['error' => $e->getMessage()]);
            throw new Exception("Export failed: " . $e->getMessage());
        }
    }

    /**
     * Get filtered users
     */
    private function getFilteredUsers()
    {
        $query = User::with([
            'person',
            'employee',
            'employee.designation',
            'employee.primaryBranch',
            'employee.primaryDepartment',
            'userDataScopes',
            'roles'
        ]);

        if (isset($this->filters['branch_id'])) {
            $query->whereHas('employee.branches', function ($q) {
                $q->where('branches.id', $this->filters['branch_id']);
            });
        }

        if (isset($this->filters['department_id'])) {
            $query->whereHas('employee.departments', function ($q) {
                $q->where('departments.id', $this->filters['department_id']);
            });
        }

        if (isset($this->filters['designation_id'])) {
            $query->whereHas('employee', function ($q) {
                $q->where('designationid', $this->filters['designation_id']);
            });
        }

        if (isset($this->filters['is_active'])) {
            $query->where('isactive', $this->filters['is_active']);
        }

        return $query->get();
    }

    /**
     * Create Users sheet
     */
    private function createUsersSheet(Spreadsheet $spreadsheet, $users)
    {
        $sheet = $spreadsheet->getActiveSheet();
        $sheet->setTitle('Users');

        // Headers
        $headers = [
            'Person Code',
            'First Name',
            'Middle Name',
            'Last Name',
            'Gender',
            'Date of Birth',
            'Marital Status',
            'Email',
            'Phone',
            'Employee Code',
            'Designation',
            'Department',
            'Branch',
            'Date of Joining',
            'Employment Type',
            'Employment Status',
            'Username',
            'User Email',
            'User Type',
            'User Status',
            'Last Login'
        ];

        // Write headers
        foreach ($headers as $col => $header) {
            $cell = $sheet->getCellByColumnAndRow($col + 1, 1);
            $cell->setValue($header);
            $cell->getStyle()->setFont(new Font(['bold' => true, 'color' => 'FFFFFF']));
            $cell->getStyle()->setFill(new Fill(['fillType' => 'solid', 'startColor' => '366092']));
            $cell->getStyle()->setAlignment(new Alignment(['horizontal' => 'center']));
        }

        // Write data
        $row = 2;
        foreach ($users as $user) {
            $person = $user->person;
            $employee = $user->employee;

            $data = [
                $person->code,
                $person->firstname,
                $person->middlename,
                $person->lastname,
                ucfirst($person->gender),
                $person->dob?->format('d-m-Y'),
                $person->maritalstatus,
                $person->emailprimary,
                $person->mobileprimary,
                $employee->code,
                $employee->designation->name,
                $employee->primaryDepartment->name,
                $employee->primaryBranch->name,
                $employee->joiningdate->format('d-m-Y'),
                ucfirst($employee->employmenttype),
                ucfirst($employee->employmentstatus),
                $user->code,
                $user->email,
                $user->userType?->name ?? 'N/A',
                $user->isactive ? 'Active' : 'Inactive',
                $user->lastloginat?->format('d-m-Y H:i'),
            ];

            foreach ($data as $col => $value) {
                $cell = $sheet->getCellByColumnAndRow($col + 1, $row);
                $cell->setValue($value);
                $cell->getStyle()->setAlignment(new Alignment(['horizontal' => 'left', 'vertical' => 'center']));
            }

            $row++;
        }

        // Auto-fit columns
        foreach (range(1, count($headers)) as $col) {
            $sheet->getColumnDimensionByColumn($col)->setAutoSize(true);
        }
    }

    /**
     * Create Assignments sheet
     */
    private function createAssignmentsSheet(Spreadsheet $spreadsheet, $users)
    {
        $sheet = $spreadsheet->createSheet();
        $sheet->setTitle('Assignments');

        // Headers
        $headers = [
            'Username',
            'Employee Code',
            'Assignment Type',
            'Entity Code',
            'Entity Name',
            'From Date',
            'To Date',
            'Is Current',
            'Additional Info'
        ];

        // Write headers
        foreach ($headers as $col => $header) {
            $cell = $sheet->getCellByColumnAndRow($col + 1, 1);
            $cell->setValue($header);
            $cell->getStyle()->setFont(new Font(['bold' => true, 'color' => 'FFFFFF']));
            $cell->getStyle()->setFill(new Fill(['fillType' => 'solid', 'startColor' => '366092']));
        }

        $row = 2;

        foreach ($users as $user) {
            $employee = $user->employee;

            // Branch assignments
            foreach ($employee->branches as $branch) {
                $pivot = $branch->pivot;
                $data = [
                    $user->code,
                    $employee->code,
                    'Branch',
                    $branch->code,
                    $branch->name,
                    $pivot->fromdate->format('d-m-Y'),
                    $pivot->todate?->format('d-m-Y') ?? 'Current',
                    $pivot->iscurrent ? 'Yes' : 'No',
                    $pivot->isprimary ? 'Primary Branch' : '',
                ];

                foreach ($data as $col => $value) {
                    $sheet->getCellByColumnAndRow($col + 1, $row)->setValue($value);
                }
                $row++;
            }

            // Department assignments
            foreach ($employee->departments as $dept) {
                $pivot = $dept->pivot;
                $data = [
                    $user->code,
                    $employee->code,
                    'Department',
                    $dept->code,
                    $dept->name,
                    $pivot->fromdate->format('d-m-Y'),
                    $pivot->todate?->format('d-m-Y') ?? 'Current',
                    $pivot->iscurrent ? 'Yes' : 'No',
                    '',
                ];

                foreach ($data as $col => $value) {
                    $sheet->getCellByColumnAndRow($col + 1, $row)->setValue($value);
                }
                $row++;
            }

            // Location assignments
            foreach ($employee->locations as $location) {
                $pivot = $location->pivot;
                $data = [
                    $user->code,
                    $employee->code,
                    'Location',
                    $location->code,
                    $location->name,
                    $pivot->fromdate->format('d-m-Y'),
                    $pivot->todate?->format('d-m-Y') ?? 'Current',
                    $pivot->iscurrent ? 'Yes' : 'No',
                    'Branch: ' . $location->branch->name,
                ];

                foreach ($data as $col => $value) {
                    $sheet->getCellByColumnAndRow($col + 1, $row)->setValue($value);
                }
                $row++;
            }

            // Post assignments
            foreach ($employee->posts as $post) {
                $pivot = $post->pivot;
                $data = [
                    $user->code,
                    $employee->code,
                    'Post',
                    $post->code,
                    $post->title,
                    $pivot->fromdate->format('d-m-Y'),
                    $pivot->todate?->format('d-m-Y') ?? 'Current',
                    $pivot->iscurrent ? 'Yes' : 'No',
                    'Order: ' . $pivot->assignmentorder . ' | Remarks: ' . ($pivot->remarks ?? 'N/A'),
                ];

                foreach ($data as $col => $value) {
                    $sheet->getCellByColumnAndRow($col + 1, $row)->setValue($value);
                }
                $row++;
            }
        }

        // Auto-fit columns
        foreach (range(1, count($headers)) as $col) {
            $sheet->getColumnDimensionByColumn($col)->setAutoSize(true);
        }
    }

    /**
     * Create Data Scopes sheet
     */
    private function createDataScopesSheet(Spreadsheet $spreadsheet, $users)
    {
        $sheet = $spreadsheet->createSheet();
        $sheet->setTitle('Data Scopes');

        // Headers
        $headers = [
            'Username',
            'Employee Code',
            'Scope Type',
            'Scope Value',
            'Entity Name',
            'Status'
        ];

        // Write headers
        foreach ($headers as $col => $header) {
            $cell = $sheet->getCellByColumnAndRow($col + 1, 1);
            $cell->setValue($header);
            $cell->getStyle()->setFont(new Font(['bold' => true, 'color' => 'FFFFFF']));
            $cell->getStyle()->setFill(new Fill(['fillType' => 'solid', 'startColor' => '366092']));
        }

        $row = 2;

        foreach ($users as $user) {
            foreach ($user->userDataScopes as $scope) {
                $entityName = $scope->getDisplayName();
                $data = [
                    $user->code,
                    $user->employee?->code ?? 'N/A',
                    ucfirst($scope->scopetype),
                    $scope->scopevalue ?? 'All (Wildcard)',
                    $entityName,
                    ucfirst($scope->status),
                ];

                foreach ($data as $col => $value) {
                    $sheet->getCellByColumnAndRow($col + 1, $row)->setValue($value);
                }
                $row++;
            }
        }

        // Auto-fit columns
        foreach (range(1, count($headers)) as $col) {
            $sheet->getColumnDimensionByColumn($col)->setAutoSize(true);
        }
    }

    /**
     * Create Summary sheet with statistics
     */
    private function createSummarySheet(Spreadsheet $spreadsheet, $users)
    {
        $sheet = $spreadsheet->createSheet();
        $sheet->setTitle('Summary');

        // Title
        $sheet->setCellValue('A1', 'VDMS User Export Summary');
        $sheet->getStyle('A1')->setFont(new Font(['bold' => true, 'size' => 14]));

        $sheet->setCellValue('A2', 'Generated: ' . Carbon::now()->format('d-m-Y H:i:s'));

        // Statistics
        $row = 4;
        $sheet->setCellValue('A' . $row, 'Total Users');
        $sheet->setCellValue('B' . $row, $users->count());
        $row++;

        $activeCount = $users->where('isactive', true)->count();
        $sheet->setCellValue('A' . $row, 'Active Users');
        $sheet->setCellValue('B' . $row, $activeCount);
        $row++;

        $inactiveCount = $users->where('isactive', false)->count();
        $sheet->setCellValue('A' . $row, 'Inactive Users');
        $sheet->setCellValue('B' . $row, $inactiveCount);
        $row += 2;

        // By Branch
        $sheet->setCellValue('A' . $row, 'Distribution by Branch');
        $sheet->getStyle('A' . $row)->setFont(new Font(['bold' => true, 'size' => 11]));
        $row++;

        $branchData = $users->groupBy(function ($user) {
            return $user->employee->primaryBranch->name;
        })->map->count();

        foreach ($branchData as $branch => $count) {
            $sheet->setCellValue('A' . $row, $branch);
            $sheet->setCellValue('B' . $row, $count);
            $row++;
        }

        // Auto-fit columns
        $sheet->getColumnDimensionByColumn(1)->setAutoSize(true);
        $sheet->getColumnDimensionByColumn(2)->setAutoSize(true);
    }

    /**
     * Get the export file path
     */
    public function getPath()
    {
        return $this->outputPath;
    }

    /**
     * Download the export file
     */
    public function download()
    {
        $this->execute();
        return response()->download($this->outputPath);
    }
}
///////End-of-File : UserExporter.php

File : VehicleDataExport.php
/////////Content of file VehicleDataExport.php
<?php

namespace App\Exports;

use App\Models\Core\Brand;
use App\Models\Core\Color;
use App\Models\Core\Segment;
use App\Models\Core\SubSegment;
use App\Models\Core\Variant;
use App\Models\Core\VehicleModel;
use Illuminate\Support\Collection;
use Maatwebsite\Excel\Concerns\FromCollection;
use Maatwebsite\Excel\Concerns\WithHeadings;
use Maatwebsite\Excel\Concerns\WithColumnWidths;

/**
 * VehicleDataExport - Export vehicle definitions to Excel
 * 
 * Mirrors the structure of vehicle_definition.xlsx import file
 * Creates one row per variant-color combination
 * 
 * Column Structure (matching importer):
 * Brand | Segment | Sub Segment | OEM Model | Custom Model | 
 * OEM Variant | Custom Variant | Model Code | Colour | Colour Code | 
 * Fuel | Seating | Wheels | CC | GVW | Body Make | Body Type | Permit | Status
 */
class VehicleDataExport implements FromCollection, WithHeadings, WithColumnWidths
{
    private $exportedCount = 0;

    public function collection(): Collection
    {
        $rows = collect();

        // Get all variants with their relationships
        $variants = Variant::with([
            'vehicleModel',
            'vehicleModel.brand',
            'vehicleModel.segment',
            'vehicleModel.subSegment',
            'colors'
        ])->get();

        // echo "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        // echo "             VEHICLE DATA EXPORT - STARTED\n";
        // echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

        // For each variant
        foreach ($variants as $variant) {
            $brand = $variant->vehicleModel->brand;
            $segment = $variant->vehicleModel->segment;
            $subSegment = $variant->vehicleModel->subSegment;
            $vehicleModel = $variant->vehicleModel;

            // Get colors for this variant
            $colors = $variant->colors()->get();

            // If no colors, create one row anyway
            if ($colors->isEmpty()) {
                $rows->push($this->buildRow($brand, $segment, $subSegment, $vehicleModel, $variant, null));
                $this->exportedCount++;
            } else {
                // Create one row per color
                foreach ($colors as $color) {
                    $rows->push($this->buildRow($brand, $segment, $subSegment, $vehicleModel, $variant, $color));
                    $this->exportedCount++;
                }
            }
        }

        // echo "âœ… EXPORT COMPLETE\n";
        // echo "   Total Variants Exported: {$this->exportedCount}\n\n";
        // echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

        return $rows;
    }

    /**
     * Build a single row of data
     */
    private function buildRow(
        Brand $brand,
        Segment $segment,
        ?SubSegment $subSegment,
        VehicleModel $vehicleModel,
        Variant $variant,
        ?Color $color
    ): array {
        return [
            // Brand
            $this->extractJsonValue($brand->name),

            // Segment
            $this->extractJsonValue($segment->name),

            // Sub Segment
            $subSegment ? $this->extractJsonValue($subSegment->name) : '',

            // OEM Model
            $vehicleModel->name ?? '',

            // Custom Model
            $vehicleModel->custom_name ?? '',

            // OEM Variant
            $variant->name ?? '',

            // Custom Variant
            $variant->custom_name ?? '',

            // Model Code
            $this->generateModelCode($variant->oem_code, $color),

            // Colour
            $color ? $this->extractJsonValue($color->name) : '',

            // Colour Code
            $color ? ($color->code ?? '') : '',

            // Fuel
            $variant->fuelType ? $variant->fuelType->value : '',

            // Seating
            $variant->seating_capacity ?? '',

            // Wheels
            $variant->wheels ?? '',

            // CC
            $variant->cc_capacity ?? '',

            // GVW
            $variant->gvwr ?? '',

            // Body Make
            $variant->bodyMake ? $variant->bodyMake->value : '',

            // Body Type
            $variant->bodyType ? $variant->bodyType->value : '',

            // Permit
            $variant->permit ? $variant->permit->value : '',

            // Status
            $variant->status ? $variant->status->value : 'ACTIVE',
        ];
    }

    /**
     * Extract value from JSON encoded field
     * 
     * Handles both:
     * {"en":"value"} format
     * Direct string format
     */
    private function extractJsonValue(?string $value): string
    {
        if (empty($value)) {
            return '';
        }

        // Try to decode JSON
        $decoded = json_decode($value, true);

        if (is_array($decoded) && isset($decoded['en'])) {
            return trim($decoded['en']);
        }

        // If not JSON, return as-is
        return trim($value);
    }

    /**
     * Generate Model Code from oem_code and color code
     * 
     * Model Code format: {oem_code}{color_code_first_2_chars}
     * Example: M00101 where M001 is oem_code and 01 is from color code
     */
    private function generateModelCode(?string $oemCode, ?Color $color): string
    {
        if (empty($oemCode)) {
            return '';
        }

        $code = trim($oemCode);

        // If color exists, append first 2 chars of color code
        if ($color && !empty($color->code)) {
            $colorCode = substr($color->code, 0, 2);
            $code .= $colorCode;
        } else {
            $code .= '00'; // Default if no color
        }

        return $code;
    }

    /**
     * Column headings matching the importer structure
     */
    public function headings(): array
    {
        return [
            'Brand',
            'Segment',
            'Sub Segment',
            'OEM Model',
            'Custom Model',
            'OEM Variant',
            'Custom Variant',
            'Model Code',
            'Colour',
            'Colour Code',
            'Fuel',
            'Seating',
            'Wheels',
            'CC',
            'GVW',
            'Body Make',
            'Body Type',
            'Permit',
            'Status',
        ];
    }

    /**
     * Column widths for better readability
     */
    public function columnWidths(): array
    {
        return [
            'A' => 15, // Brand
            'B' => 15, // Segment
            'C' => 15, // Sub Segment
            'D' => 18, // OEM Model
            'E' => 18, // Custom Model
            'F' => 18, // OEM Variant
            'G' => 18, // Custom Variant
            'H' => 12, // Model Code
            'I' => 15, // Colour
            'J' => 12, // Colour Code
            'K' => 12, // Fuel
            'L' => 10, // Seating
            'M' => 10, // Wheels
            'N' => 10, // CC
            'O' => 10, // GVW
            'P' => 15, // Body Make
            'Q' => 15, // Body Type
            'R' => 12, // Permit
            'S' => 12, // Status
        ];
    }
}
///////End-of-File : VehicleDataExport.php

Folder : d:\xampp\htdocs\vdms\app\.\Facades

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Facades

File : f
/////////Content of file f
///////End-of-File : f

File : KeywordValue.php
/////////Content of file KeywordValue.php
<?php

namespace App\Facades;

use Illuminate\Support\Facades\Facade;

/**
 * @method static int|null getValueId(string $keyword, string $key, bool $activeOnly = true)
 * @method static \App\Models\Core\Keyvalue|null getValue(string $keyword, string $key, bool $activeOnly = true)
 * @method static array getValues(string $keyword, bool $activeOnly = true)
 * @method static \Illuminate\Database\Eloquent\Collection getValueObjects(string $keyword, bool $activeOnly = true, bool $recursive = false)
 * @method static int|null getKeywordId(string $keyword)
 * @method static \App\Models\Core\Keyvalue|null getValueByValue(string $keyword, string $value, bool $activeOnly = true)
 * @method static bool keywordExists(string $keyword)
 * @method static bool valueExists(string $keyword, string $key, bool $activeOnly = true)
 * @method static array getEnum(string $keyword, bool $activeOnly = true)
 * @method static void clearCache(string|null $keyword = null)
 * @method static int|null findValueId(string $keyword, string $searchTerm, bool $activeOnly = true)
 * 
 * @see \App\Services\KeywordValueService
 */
class KeywordValue extends Facade
{
    protected static function getFacadeAccessor(): string
    {
        return 'keyword-value';
    }
}
///////End-of-File : KeywordValue.php

Folder : d:\xampp\htdocs\vdms\app\.\Http

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Http

Folder : d:\xampp\htdocs\vdms\app\.\Http\Controllers

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Http\Controllers

File : Controller.php
/////////Content of file Controller.php
<?php

namespace App\Http\Controllers;

abstract class Controller
{
    //
}
///////End-of-File : Controller.php

File : e
/////////Content of file e
///////End-of-File : e

File : ExportController.php
/////////Content of file ExportController.php
<?php

namespace App\Http\Controllers;

use App\Exports\VehicleDataExport;
use Maatwebsite\Excel\Facades\Excel;
use Symfony\Component\HttpFoundation\StreamedResponse;

class ExportController extends Controller
{
    /**
     * Download vehicle data as Excel file
     * GET /export/vehicle-data
     */
    public function vehicleDataExcel()
    {
        try {
            $filename = 'VehicleDataExport_' . now()->format('d-m-Y-H-i-s') . '.xlsx';

            return Excel::download(new VehicleDataExport(), $filename);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Export failed: ' . $e->getMessage()
            ], 500);
        }
    }

    /**
     * Download vehicle data as CSV file
     * GET /export/vehicle-data-csv
     */
    public function vehicleDataCsv()
    {
        try {
            $filename = 'VehicleDataExport_' . now()->format('d-m-Y-H-i-s') . '.csv';

            return Excel::download(new VehicleDataExport(), $filename, \Maatwebsite\Excel\Excel::CSV);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Export failed: ' . $e->getMessage()
            ], 500);
        }
    }

    /**
     * Stream vehicle data as CSV (pure PHP, no Excel library)
     * GET /export/vehicle-data-simple-csv
     */
    public function vehicleDataSimpleCsv()
    {
        try {
            $export = new VehicleDataExport();
            $data = $export->collection();

            $filename = 'VehicleDataExport_' . now()->format('d-m-Y-H-i-s') . '.csv';

            // Create CSV response
            $callback = function () use ($data) {
                $file = fopen('php://output', 'w');

                // Add headers
                if ($data->count() > 0) {
                    $firstRow = $data->first();
                    if (is_array($firstRow)) {
                        fputcsv($file, array_keys($firstRow));
                    }
                }

                // Add data rows
                foreach ($data as $row) {
                    if (is_array($row)) {
                        fputcsv($file, $row);
                    }
                }

                fclose($file);
            };

            return response()->stream($callback, 200, [
                'Content-Type' => 'text/csv; charset=UTF-8',
                'Content-Disposition' => "attachment; filename=\"{$filename}\"",
                'Pragma' => 'no-cache',
                'Cache-Control' => 'must-revalidate, post-check=0, pre-check=0',
                'Expires' => '0',
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'error' => 'Export failed: ' . $e->getMessage()
            ], 500);
        }
    }
}
///////End-of-File : ExportController.php

File : UserImportExportController.php
/////////Content of file UserImportExportController.php
<?php

namespace App\Http\Controllers;

use App\Services\Exporters\UserExporter;
use App\Services\Importers\UserImporter;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

class UserImportExportController extends Controller
{
    /**
     * Show import form
     */
    public function showImportForm()
    {
        return view('admin.users.import');
    }

    /**
     * Handle file upload and import
     */
    public function import(Request $request)
    {
        try {
            $request->validate([
                'file' => 'required|file|mimes:xlsx,xls,csv|max:10240', // 10MB max
            ]);

            // Store uploaded file temporarily
            $file = $request->file('file');
            $filename = 'import_' . Str::random(10) . '.' . $file->getClientOriginalExtension();
            $path = $file->storeAs('imports', $filename, 'local');
            $fullPath = storage_path('app/' . $path);

            // Execute import
            $importer = new UserImporter($fullPath);
            $result = $importer->execute();

            // Clean up temp file
            if (file_exists($fullPath)) {
                unlink($fullPath);
            }

            // Return result
            if ($result['success']) {
                return response()->json([
                    'success' => true,
                    'message' => $result['message'],
                    'data' => $result,
                ], 200);
            } else {
                return response()->json([
                    'success' => false,
                    'message' => 'Import completed with errors',
                    'data' => $result,
                ], 422);
            }
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Import failed: ' . $e->getMessage(),
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Show export form
     */
    public function showExportForm()
    {
        return view('admin.users.export');
    }

    /**
     * Handle export
     */
    public function export(Request $request)
    {
        try {
            $request->validate([
                'branch_id' => 'nullable|exists:branches,id',
                'department_id' => 'nullable|exists:departments,id',
                'designation_id' => 'nullable|exists:designations,id',
                'status' => 'nullable|in:active,inactive,all',
            ]);

            // Build filters
            $filters = [];
            if ($request->branch_id) {
                $filters['branch_id'] = $request->branch_id;
            }
            if ($request->department_id) {
                $filters['department_id'] = $request->department_id;
            }
            if ($request->designation_id) {
                $filters['designation_id'] = $request->designation_id;
            }
            if ($request->status && $request->status !== 'all') {
                $filters['is_active'] = ($request->status === 'active');
            }

            // Create exporter
            $exporter = new UserExporter();
            $exporter->withFilters($filters);
            $result = $exporter->execute();

            // Return download
            if ($result['success']) {
                return response()->download($result['path'], $result['filename']);
            } else {
                return back()->with('error', 'Export failed: ' . $result['message']);
            }
        } catch (Exception $e) {
            return back()->with('error', 'Export failed: ' . $e->getMessage());
        }
    }

    /**
     * Download template
     */
    public function downloadTemplate()
    {
        $filename = 'user_import_template.xlsx';
        $path = resource_path('templates/' . $filename);

        if (!file_exists($path)) {
            // Create template if it doesn't exist
            $this->generateTemplate($path);
        }

        return response()->download($path, 'vdms_user_import_template.xlsx');
    }

    /**
     * Generate import template
     */
    private function generateTemplate($path)
    {
        $spreadsheet = new \PhpOffice\PhpSpreadsheet\Spreadsheet();
        $sheet = $spreadsheet->getActiveSheet();
        $sheet->setTitle('Users');

        // Headers
        $headers = [
            'Person Code',
            'First Name',
            'Middle Name',
            'Last Name',
            'Gender',
            'Date of Birth',
            'Marital Status',
            'Email',
            'Phone',
            'Employee Code',
            'Designation',
            'Department',
            'Branch',
            'Location',
            'Division',
            'Vertical',
            'Post',
            'Date of Joining',
            'Employment Type',
            'Employment Status',
            'Username',
            'Email Login',
            'User Type',
            'User Status',
            'Accessible Branches',
            'Accessible Departments',
            'Accessible Locations',
        ];

        // Write headers
        foreach ($headers as $col => $header) {
            $cell = $sheet->getCellByColumnAndRow($col + 1, 1);
            $cell->setValue($header);
            $cell->getStyle()->setFont(new \PhpOffice\PhpSpreadsheet\Style\Font([
                'bold' => true,
                'color' => 'FFFFFF'
            ]));
            $cell->getStyle()->setFill(new \PhpOffice\PhpSpreadsheet\Style\Fill([
                'fillType' => 'solid',
                'startColor' => '366092'
            ]));
        }

        // Add instructions
        $sheet->setCellValue('A' . 3, 'INSTRUCTIONS:');
        $sheet->getStyle('A3')->setFont(new \PhpOffice\PhpSpreadsheet\Style\Font(['bold' => true, 'italic' => true]));

        $instructions = [
            '- Person Code: Auto-generated if left blank',
            '- Date fields: Use DD-MM-YYYY format',
            '- Gender: male, female, other, prefernottosay',
            '- Employment Type: permanent, contract, temporary, probation',
            '- Employment Status: active, inactive, resigned',
            '- User Status: Active or Inactive',
            '- Designation, Department, Branch, etc: Must match existing codes',
            '- Multiple assignments: Separate with commas (e.g., BR001, BR002)',
            '- Leave optional fields blank if not applicable',
            '- Email must be unique per user',
            '- Username must be unique per user',
        ];

        foreach ($instructions as $idx => $instruction) {
            $sheet->setCellValue('A' . (4 + $idx), $instruction);
        }

        // Auto-fit columns
        foreach (range(1, count($headers)) as $col) {
            $sheet->getColumnDimensionByColumn($col)->setAutoSize(true);
        }

        // Save
        @mkdir(dirname($path), 0755, true);
        $writer = new \PhpOffice\PhpSpreadsheet\Writer\Xlsx($spreadsheet);
        $writer->save($path);
    }

    /**
     * Get import history
     */
    public function importHistory()
    {
        // Fetch from audit logs or create a dedicated import_logs table
        $imports = \DB::table('import_logs')
            ->orderBy('created_at', 'desc')
            ->paginate(20);

        return view('admin.users.import-history', compact('imports'));
    }

    /**
     * Get export history
     */
    public function exportHistory()
    {
        $exports = \DB::table('export_logs')
            ->orderBy('created_at', 'desc')
            ->paginate(20);

        return view('admin.users.export-history', compact('exports'));
    }
}
///////End-of-File : UserImportExportController.php

Folder : d:\xampp\htdocs\vdms\app\.\Http\Controllers\Admin

Folder : d:\xampp\htdocs\vdms\app\.\Http\Controllers\Api

Folder : d:\xampp\htdocs\vdms\app\.\Http\Middleware

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Http\Middleware

File : CheckIfAdmin.php
/////////Content of file CheckIfAdmin.php
<?php

namespace App\Http\Middleware;

use Closure;

class CheckIfAdmin
{
    /**
     * Checked that the logged in user is an administrator.
     *
     * --------------
     * VERY IMPORTANT
     * --------------
     * If you have both regular users and admins inside the same table, change
     * the contents of this method to check that the logged in user
     * is an admin, and not a regular user.
     *
     * Additionally, in Laravel 7+, you should change app/Providers/RouteServiceProvider::HOME
     * which defines the route where a logged in user (but not admin) gets redirected
     * when trying to access an admin route. By default it's '/home' but Backpack
     * does not have a '/home' route, use something you've built for your users
     * (again - users, not admins).
     *
     * @param  \Illuminate\Contracts\Auth\Authenticatable|null  $user
     * @return bool
     */
    private function checkIfUserIsAdmin($user)
    {
        // return ($user->is_admin == 1);
        return true;
    }

    /**
     * Answer to unauthorized access request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response|\Illuminate\Http\RedirectResponse
     */
    private function respondToUnauthorizedRequest($request)
    {
        if ($request->ajax() || $request->wantsJson()) {
            return response(trans('backpack::base.unauthorized'), 401);
        } else {
            return redirect()->guest(backpack_url('login'));
        }
    }

    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if (backpack_auth()->guest()) {
            return $this->respondToUnauthorizedRequest($request);
        }

        if (! $this->checkIfUserIsAdmin(backpack_user())) {
            return $this->respondToUnauthorizedRequest($request);
        }

        return $next($request);
    }
}
///////End-of-File : CheckIfAdmin.php

File : CheckPermission.php
/////////Content of file CheckPermission.php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * Permission Checking Middleware
 * 
 * Usage in routes:
 * Route::get('/branches', [BranchController::class, 'index'])
 *     ->middleware('checkPermission:branch.view,branch.list');
 * 
 * Multiple permissions (OR logic - user needs at least one):
 * ->middleware('checkPermission:branch.view,branch.list')
 * 
 * Supports wildcards:
 * ->middleware('checkPermission:branch.*')
 */
class CheckPermission
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     * @param  string  ...$permissions
     * @return \Symfony\Component\HttpFoundation\Response
     */
    public function handle(Request $request, Closure $next, ...$permissions): Response
    {
        $user = auth()->user();

        // No authenticated user
        if (!$user) {
            return $this->unauthorized($request);
        }

        // Check if user has any of the required permissions (OR logic)
        if (!$this->hasAnyPermission($user, $permissions)) {
            return $this->unauthorized($request);
        }

        return $next($request);
    }

    /**
     * Check if user has any of the required permissions
     *
     * @param  mixed  $user
     * @param  array  $permissions
     * @return bool
     */
    private function hasAnyPermission($user, array $permissions): bool
    {
        foreach ($permissions as $permission) {
            if ($this->checkPermission($user, $permission)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if user has a specific permission (supports wildcards)
     *
     * @param  mixed  $user
     * @param  string  $permission
     * @return bool
     */
    private function checkPermission($user, string $permission): bool
    {
        // Remove any whitespace
        $permission = trim($permission);

        // Check for wildcard permission (e.g., branch.*)
        if (str_ends_with($permission, '.*')) {
            $prefix = substr($permission, 0, -2);
            return $user->hasPermissionTo($prefix . '.view') ||
                $user->hasPermissionTo($prefix . '.create') ||
                $user->hasPermissionTo($prefix . '.edit') ||
                $user->hasPermissionTo($prefix . '.delete');
        }

        // Standard permission check
        return $user->hasPermissionTo($permission);
    }

    /**
     * Return unauthorized response
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Symfony\Component\HttpFoundation\Response
     */
    private function unauthorized(Request $request): Response
    {
        if ($request->expectsJson()) {
            return response()->json([
                'message' => 'Unauthorized: Insufficient permissions',
                'status' => 403,
            ], 403);
        }

        abort(403, 'Unauthorized: You do not have permission to access this resource.');
    }
}
///////End-of-File : CheckPermission.php

File : CheckSuperAdmin.php
/////////Content of file CheckSuperAdmin.php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * Super Admin Checking Middleware
 * 
 * Allows only users with super_admin or admin role
 * 
 * Usage in routes:
 * Route::patch('/branches/{id}', [BranchController::class, 'update'])
 *     ->middleware('checkSuperAdmin');
 */
class CheckSuperAdmin
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     * @return \Symfony\Component\HttpFoundation\Response
     */
    public function handle(Request $request, Closure $next): Response
    {
        $user = auth()->user();

        // Check if user is authenticated
        if (!$user) {
            return $this->unauthorized($request, 'Unauthenticated');
        }

        // Check if user has super admin role
        if (!$user->isSuperAdmin()) {
            return $this->unauthorized($request, 'Super admin access required');
        }

        return $next($request);
    }

    /**
     * Return unauthorized response
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  string  $message
     * @return \Symfony\Component\HttpFoundation\Response
     */
    private function unauthorized(Request $request, string $message = 'Unauthorized'): Response
    {
        if ($request->expectsJson()) {
            return response()->json([
                'message' => $message,
                'status' => 403,
            ], 403);
        }

        abort(403, $message);
    }
}
///////End-of-File : CheckSuperAdmin.php

File : v
/////////Content of file v
///////End-of-File : v

File : ValidateDeviceMiddleware.php
/////////Content of file ValidateDeviceMiddleware.php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
use App\Models\Core\DeviceSession;
use App\Models\Core\OtpAttemptLog;

class ValidateDeviceMiddleware
{
    public function handle(Request $request, Closure $next): Response
    {
        $user = $request->user('sanctum');
        if (!$user) {
            return response()->json([
                'http_status' => 401,
                'success' => false,
                'code' => 'E002',
                'message' => 'Unauthorized: User not authenticated',
            ], 401);
        }

        $token = $user->currentAccessToken();
        if (!$token) {
            return response()->json([
                'http_status' => 401,
                'success' => false,
                'code' => 'E002',
                'message' => 'Unauthorized: No valid token',
            ], 401);
        }

        $deviceId = $token->abilities['device_id'] ?? null;
        if (!$deviceId) {
            return response()->json([
                'http_status' => 401,
                'success' => false,
                'code' => 'E002',
                'message' => 'Unauthorized: No device bound',
            ], 401);
        }

        $deviceSession = DeviceSession::where('user_id', $user->id)->where('device_id', $deviceId)->first();
        if (!$deviceSession || $deviceSession->deleted_at) {
            OtpAttemptLog::create([
                'user_id' => $user->id,
                'mobile' => $user->phone,
                'action' => 'locked',
                'ip_address' => $request->ip(),
                'user_agent' => $request->userAgent(),
                'reason' => 'Invalid or revoked device',
                'created_by' => $user->id,
            ]);

            return response()->json([
                'http_status' => 401,
                'success' => false,
                'code' => 'E002',
                'message' => 'Unauthorized: Invalid device session',
            ], 401);
        }

        $deviceSession->update([
            'last_active_at' => now(),
            'updated_by' => $user->id,
        ]);

        $request->attributes->set('device_session', $deviceSession);

        return $next($request);
    }
}
///////End-of-File : ValidateDeviceMiddleware.php

Folder : d:\xampp\htdocs\vdms\app\.\Http\Requests

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Http\Requests

File : ApprovalHierarchyRequest.php
/////////Content of file ApprovalHierarchyRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ApprovalHierarchyRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : ApprovalHierarchyRequest.php

File : BranchRequest.php
/////////Content of file BranchRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class BranchRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : BranchRequest.php

File : BrandRequest.php
/////////Content of file BrandRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class BrandRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : BrandRequest.php

File : ColorRequest.php
/////////Content of file ColorRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ColorRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : ColorRequest.php

File : DashboardControllerRequest.php
/////////Content of file DashboardControllerRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class DashboardControllerRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : DashboardControllerRequest.php

File : DepartmentRequest.php
/////////Content of file DepartmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class DepartmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : DepartmentRequest.php

File : DesignationRequest.php
/////////Content of file DesignationRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class DesignationRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : DesignationRequest.php

File : DivisionRequest.php
/////////Content of file DivisionRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class DivisionRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : DivisionRequest.php

File : EmployeeBranchAssignmentRequest.php
/////////Content of file EmployeeBranchAssignmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class EmployeeBranchAssignmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : EmployeeBranchAssignmentRequest.php

File : EmployeeDepartmentAssignmentRequest.php
/////////Content of file EmployeeDepartmentAssignmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class EmployeeDepartmentAssignmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : EmployeeDepartmentAssignmentRequest.php

File : EmployeeLocationAssignmentRequest.php
/////////Content of file EmployeeLocationAssignmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class EmployeeLocationAssignmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : EmployeeLocationAssignmentRequest.php

File : EmployeePostAssignmentRequest.php
/////////Content of file EmployeePostAssignmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class EmployeePostAssignmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : EmployeePostAssignmentRequest.php

File : EmployeeRequest.php
/////////Content of file EmployeeRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class EmployeeRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : EmployeeRequest.php

File : EmployeeVerticalAssignmentRequest.php
/////////Content of file EmployeeVerticalAssignmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class EmployeeVerticalAssignmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : EmployeeVerticalAssignmentRequest.php

File : GarageRequest.php
/////////Content of file GarageRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class GarageRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : GarageRequest.php

File : GraphEdgeRequest.php
/////////Content of file GraphEdgeRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class GraphEdgeRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : GraphEdgeRequest.php

File : GraphNodeRequest.php
/////////Content of file GraphNodeRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class GraphNodeRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : GraphNodeRequest.php

File : KeyvalueRequest.php
/////////Content of file KeyvalueRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class KeyvalueRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : KeyvalueRequest.php

File : KeywordMasterRequest.php
/////////Content of file KeywordMasterRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class KeywordMasterRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : KeywordMasterRequest.php

File : LocationRequest.php
/////////Content of file LocationRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class LocationRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : LocationRequest.php

File : ModulesRequest.php
/////////Content of file ModulesRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ModulesRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : ModulesRequest.php

File : PermissionRequest.php
/////////Content of file PermissionRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PermissionRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : PermissionRequest.php

File : PersonAddressRequest.php
/////////Content of file PersonAddressRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PersonAddressRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : PersonAddressRequest.php

File : PersonBankingDetailRequest.php
/////////Content of file PersonBankingDetailRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PersonBankingDetailRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : PersonBankingDetailRequest.php

File : PersonContactRequest.php
/////////Content of file PersonContactRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PersonContactRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : PersonContactRequest.php

File : PersonRequest.php
/////////Content of file PersonRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PersonRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : PersonRequest.php

File : PostPermissionRequest.php
/////////Content of file PostPermissionRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PostPermissionRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : PostPermissionRequest.php

File : PostRequest.php
/////////Content of file PostRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PostRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : PostRequest.php

File : ProcessRequest.php
/////////Content of file ProcessRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ProcessRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : ProcessRequest.php

File : ReportingHierarchyRequest.php
/////////Content of file ReportingHierarchyRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class ReportingHierarchyRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : ReportingHierarchyRequest.php

File : SegmentRequest.php
/////////Content of file SegmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class SegmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : SegmentRequest.php

File : SubSegmentRequest.php
/////////Content of file SubSegmentRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class SubSegmentRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : SubSegmentRequest.php

File : UserRequest.php
/////////Content of file UserRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class UserRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : UserRequest.php

File : UserTypeRequest.php
/////////Content of file UserTypeRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class UserTypeRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : UserTypeRequest.php

File : VariantRequest.php
/////////Content of file VariantRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class VariantRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : VariantRequest.php

File : VehicleModelRequest.php
/////////Content of file VehicleModelRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class VehicleModelRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : VehicleModelRequest.php

File : VerticalRequest.php
/////////Content of file VerticalRequest.php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class VerticalRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     *
     * @return bool
     */
    public function authorize()
    {
        // only allow updates if the user is logged in
        return backpack_auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array
     */
    public function rules()
    {
        return [
            // 'name' => 'required|min:5|max:255'
        ];
    }

    /**
     * Get the validation attributes that apply to the request.
     *
     * @return array
     */
    public function attributes()
    {
        return [
            //
        ];
    }

    /**
     * Get the validation messages that apply to the request.
     *
     * @return array
     */
    public function messages()
    {
        return [
            //
        ];
    }
}
///////End-of-File : VerticalRequest.php

Folder : d:\xampp\htdocs\vdms\app\.\Imports

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Imports

File : i
/////////Content of file i
///////End-of-File : i

File : RulesUserImporter.php
/////////Content of file RulesUserImporter.php
<?php

namespace App\Services\Importers;

use App\Models\Core\Branch;
use App\Models\Core\Color;
use App\Models\Core\Department;
use App\Models\Core\Division;
use App\Models\Core\Employee;
use App\Models\Core\Person;
use App\Models\Core\Post;
use App\Models\Core\Segment;
use App\Models\Core\SubSegment;
use App\Models\User;
use App\Models\UserDataScope;
use App\Models\Core\Variant;
use App\Models\Core\VariantColor;
use App\Models\Core\Vertical;
use App\Models\Core\VehicleModel;
use Carbon\Carbon;
use DB;
use Exception;
use Illuminate\Support\Str;
use PhpOffice\PhpSpreadsheet\IOFactory;

class RulesUserImporter
{
    private $filePath;
    private $sheetName = 'User List';
    private $startRow = 2;

    private $errors = [];
    private $warnings = [];
    private $imported = 0;
    private $skipped = 0;
    private $updated = 0;

    private $mobileSequence = 9811122001;
    private $importedUserIds = [];
    private $existingUsers = [];

    public function __construct($filePath, $sheetName = null)
    {
        $this->filePath = $filePath;
        if ($sheetName) {
            $this->sheetName = $sheetName;
        }

        // Pre-load existing users for update detection
        $this->existingUsers = User::pluck('id', 'code')->toArray();
    }

    /**
     * Execute the import process
     */
    public function execute()
    {
        $startTime = microtime(true);

        try {
            $spreadsheet = IOFactory::load($this->filePath);

            // Check if sheet exists
            if (!$spreadsheet->sheetNameExists($this->sheetName)) {
                return $this->formatResult(false, "Sheet '{$this->sheetName}' not found");
            }

            $worksheet = $spreadsheet->getSheetByName($this->sheetName);
            $maxRow = $worksheet->getHighestRow();

            DB::beginTransaction();

            // Process each row
            for ($row = $this->startRow; $row <= $maxRow; $row++) {
                try {
                    $data = $this->extractRowData($worksheet, $row);

                    if (empty($data['Emp Code'])) {
                        $this->skipped++;
                        continue;
                    }

                    $this->processUserRow($data, $row);
                } catch (Exception $e) {
                    $this->errors[] = [
                        'row' => $row,
                        'error' => $e->getMessage(),
                    ];
                    $this->skipped++;
                }
            }

            DB::commit();

            $duration = round(microtime(true) - $startTime, 2);

            return $this->formatResult(
                true,
                "Import completed successfully. Imported: {$this->imported}, Updated: {$this->updated}, Skipped: {$this->skipped}",
                $duration
            );
        } catch (Exception $e) {
            DB::rollBack();

            return $this->formatResult(false, "Import failed: " . $e->getMessage());
        }
    }

    /**
     * Extract data from a single row
     */
    private function extractRowData($worksheet, $row)
    {
        return [
            'S.No' => $worksheet->getCell("A{$row}")->getValue(),
            'Name' => $worksheet->getCell("B{$row}")->getValue(),
            'Email' => $worksheet->getCell("C{$row}")->getValue(),
            'Mobile' => $worksheet->getCell("D{$row}")->getValue(),
            'Mile ID' => $worksheet->getCell("E{$row}")->getValue(),
            'Emp Code' => $worksheet->getCell("F{$row}")->getValue(),
            'Designation' => $worksheet->getCell("G{$row}")->getValue(),
            'Department' => $worksheet->getCell("H{$row}")->getValue(),
            'Sub Department' => $worksheet->getCell("I{$row}")->getValue(),
            'Location' => $worksheet->getCell("J{$row}")->getValue(),
            'Branch' => $worksheet->getCell("K{$row}")->getValue(),
            'Vertical' => $worksheet->getCell("L{$row}")->getValue(),
            'Segment' => $worksheet->getCell("M{$row}")->getValue(),
            'Sub Segment' => $worksheet->getCell("N{$row}")->getValue(),
            'Models' => $worksheet->getCell("O{$row}")->getValue(),
            'User ID' => $worksheet->getCell("P{$row}")->getValue(),
            'Password' => $worksheet->getCell("Q{$row}")->getValue(),
        ];
    }

    /**
     * Process a complete user row
     */
    private function processUserRow($data, $row)
    {
        // Parse name
        $nameParts = $this->parseName($data['Name']);
        $firstName = $nameParts['first_name'];
        $lastName = $nameParts['last_name'];

        // Generate/get email
        $email = $this->generateEmail($data['Email'], $firstName, $data['Emp Code']);

        // Generate/get mobile
        $mobile = $this->generateMobile($data['Mobile']);

        // Get or create Person
        $person = $this->getOrCreatePerson([
            'first_name' => $firstName,
            'last_name' => $lastName,
            'email_primary' => $email,
            'mobile_primary' => $mobile,
        ]);

        // Lookup required entities
        $designation = $this->lookupDesignation($data['Designation']);
        $department = $this->lookupDepartment($data['Department']);
        if (!$designation || !$department) {
            throw new Exception("Designation or Department not found");
        }

        // Get or create Employee
        $employee = $this->getOrCreateEmployee([
            'person_id' => $person->id,
            'code' => $data['Emp Code'],
            'designation_id' => $designation->id,
            'primary_department_id' => $department->id,
            'joining_date' => now()->toDateString(),
        ]);

        // Determine if new or existing user
        $isNewUser = !isset($this->existingUsers[$data['Emp Code']]);

        // Generate User ID and Password
        $userId = $data['User ID'] ?? $this->generateUserId($data['Emp Code']);
        $password = $this->generatePassword($data['Password'] ?? $data['Emp Code']);

        // Get or create User
        $user = $this->getOrCreateUser([
            'person_id' => $person->id,
            'employee_id' => $employee->id,
            'code' => $userId,
            'email' => $email,
            'password' => $password,
            'name' => "{$firstName} {$lastName}",
        ]);

        // Track imported user
        $this->importedUserIds[] = $user->id;

        if ($isNewUser) {
            $this->imported++;
        } else {
            $this->updated++;
        }

        // Clear old assignments if updating
        if (!$isNewUser) {
            $employee->branches()->detach();
            $employee->departments()->detach();
            $employee->locations()->detach();
            $employee->divisions()->detach();
            $employee->verticals()->detach();
            $employee->posts()->detach();
            $user->userDataScopes()->delete();
        }

        // Process multi-value assignments
        $this->processAssignments($employee, $user, $data);
    }

    /**
     * Process all assignments for user
     */
    private function processAssignments($employee, $user, $data)
    {
        // Branch assignments (with Location scoping)
        $branches = $this->parseMultiValue($data['Branch']);
        foreach ($branches as $branchCode) {
            $branch = Branch::where('code', $branchCode)->first();
            if ($branch) {
                $employee->branches()->attach($branch->id, [
                    'from_date' => now(),
                    'is_primary' => count($branches) === 1,
                    'is_current' => true,
                ]);

                // Create data scope for branch (NULL location = all locations)
                $location = $this->lookupLocation($data['Location']);
                $this->createDataScope($user, 'branch', $location ? null : $branch->id, 'branch');
            }
        }

        // Location assignments if specified
        if (!empty($data['Location'])) {
            $locations = $this->parseMultiValue($data['Location']);
            foreach ($locations as $locationCode) {
                $location = Location::where('code', $locationCode)->first();
                if ($location) {
                    $employee->locations()->attach($location->id, [
                        'from_date' => now(),
                        'is_current' => true,
                    ]);

                    // Create data scope for location
                    $this->createDataScope($user, 'location', $location->id);
                }
            }
        }

        // Department assignments (with Division scoping)
        $departments = $this->parseMultiValue($data['Department']);
        foreach ($departments as $deptCode) {
            $dept = Department::where('code', $deptCode)->first();
            if ($dept) {
                $employee->departments()->attach($dept->id, [
                    'from_date' => now(),
                    'is_current' => true,
                ]);

                // Create data scope for department (NULL division = all divisions)
                $division = $this->lookupDivision($data['Sub Department']);
                $this->createDataScope($user, 'department', $division ? null : $dept->id, 'department');
            }
        }

        // Division (Sub Department) assignments if specified
        if (!empty($data['Sub Department'])) {
            $divisions = $this->parseMultiValue($data['Sub Department']);
            foreach ($divisions as $divCode) {
                $division = Division::where('code', $divCode)->first();
                if ($division) {
                    $employee->divisions()->attach($division->id, [
                        'from_date' => now(),
                        'is_current' => true,
                    ]);

                    // Create data scope for division
                    $this->createDataScope($user, 'division', $division->id);
                }
            }
        }

        // Vertical assignments
        if (!empty($data['Vertical'])) {
            $verticals = $this->parseMultiValue($data['Vertical']);
            foreach ($verticals as $vertCode) {
                $vertical = Vertical::where('code', $vertCode)->first();
                if ($vertical) {
                    $employee->verticals()->attach($vertical->id, [
                        'from_date' => now(),
                        'is_current' => true,
                    ]);

                    $this->createDataScope($user, 'vertical', $vertical->id);
                }
            }
        }

        // Brand/Segment/SubSegment/VehicleModel/Variant/Variant_Color hierarchy
        if (!empty($data['Segment'])) {
            $segments = $this->parseMultiValue($data['Segment']);
            foreach ($segments as $segCode) {
                $segment = Segment::where('code', $segCode)->first();
                if ($segment) {
                    $this->createDataScope($user, 'segment', $segment->id);

                    // If SubSegment specified, scope to that; else scope to all subsegments
                    if (!empty($data['Sub Segment'])) {
                        $subSegments = $this->parseMultiValue($data['Sub Segment']);
                        foreach ($subSegments as $subSegCode) {
                            $subSegment = SubSegment::where('code', $subSegCode)->first();
                            if ($subSegment) {
                                $this->createDataScope($user, 'subsegment', $subSegment->id);

                                // If Models specified, scope to those; else scope to all
                                if (!empty($data['Models'])) {
                                    $models = $this->parseMultiValue($data['Models']);
                                    foreach ($models as $modelCode) {
                                        $model = VehicleModel::where('code', $modelCode)->first();
                                        if ($model) {
                                            $this->createDataScope($user, 'vehiclemodel', $model->id);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Parse comma-separated values
     */
    private function parseMultiValue($value)
    {
        if (empty($value)) {
            return [];
        }

        return array_filter(
            array_map('trim', explode(',', $value)),
            fn($v) => !empty($v)
        );
    }

    /**
     * Parse name into first and last
     */
    private function parseName($name)
    {
        $parts = array_map('trim', explode(' ', trim($name), 2));

        return [
            'first_name' => $parts[0] ?? '',
            'last_name' => $parts[1] ?? $parts[0] ?? '',
        ];
    }

    /**
     * Generate email if missing
     */
    private function generateEmail($email, $firstName, $empCode)
    {
        if (!empty($email)) {
            return $email;
        }

        $slug = Str::slug("{$firstName}.{$empCode}", '.');
        return "{$slug}@bmpl.com";
    }

    /**
     * Generate mobile if missing
     */
    private function generateMobile($mobile)
    {
        if (!empty($mobile)) {
            return $mobile;
        }

        $generated = $this->mobileSequence;
        $this->mobileSequence++;
        return (string)$generated;
    }

    /**
     * Generate user ID from employee code
     */
    private function generateUserId($empCode)
    {
        return str_replace([' ', '-'], '', $empCode);
    }

    /**
     * Generate password
     */
    private function generatePassword($empCode)
    {
        $sanitized = str_replace([' ', '-', 'BMPL'], '', $empCode);
        return "user@bmpl#{$sanitized}";
    }

    /**
     * Get or create Person
     */
    private function getOrCreatePerson($data)
    {
        return Person::updateOrCreate(
            ['email_primary' => $data['email_primary']],
            [
                'first_name' => $data['first_name'],
                'last_name' => $data['last_name'],
                'mobile_primary' => $data['mobile_primary'],
                'display_name' => "{$data['first_name']} {$data['last_name']}",
            ]
        );
    }

    /**
     * Get or create Employee
     */
    private function getOrCreateEmployee($data)
    {
        return Employee::updateOrCreate(
            ['code' => $data['code']],
            [
                'person_id' => $data['person_id'],
                'designation_id' => $data['designation_id'],
                'primary_department_id' => $data['primary_department_id'],
                'joining_date' => $data['joining_date'],
                'is_active' => true,
            ]
        );
    }

    /**
     * Get or create User
     */
    private function getOrCreateUser($data)
    {
        return User::updateOrCreate(
            ['code' => $data['code']],
            [
                'person_id' => $data['person_id'],
                'employee_id' => $data['employee_id'],
                'email' => $data['email'],
                'password' => bcrypt($data['password']),
                'name' => $data['name'],
                'is_active' => true,
            ]
        );
    }

    /**
     * Create data scope for RBAC
     */
    private function createDataScope($user, $scopeType, $scopeValue, $contextType = null)
    {
        UserDataScope::create([
            'user_id' => $user->id,
            'scope_type' => $scopeType,
            'scope_value' => $scopeValue,  // NULL means all children
            'status' => 'active',
        ]);
    }

    /**
     * Lookup helpers
     */
    private function lookupDesignation($code)
    {
        return \App\Models\Designation::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    private function lookupDepartment($code)
    {
        return Department::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    private function lookupDivision($code)
    {
        if (empty($code)) return null;

        return Division::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    private function lookupLocation($code)
    {
        if (empty($code)) return null;

        return \App\Models\Location::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    /**
     * Format result
     */
    private function formatResult($success, $message, $duration = 0)
    {
        return [
            'success' => $success,
            'imported' => $this->imported,
            'updated' => $this->updated,
            'skipped' => $this->skipped,
            'total_processed' => $this->imported + $this->updated + $this->skipped,
            'errors' => $this->errors,
            'warnings' => $this->warnings,
            'message' => $message,
            'duration_seconds' => $duration,
        ];
    }
}
///////End-of-File : RulesUserImporter.php

File : UserImporter.php
/////////Content of file UserImporter.php
<?php

namespace App\Services\Importers;

use App\Models\Core\Person;
use App\Models\Core\Employee;
use App\Models\User;
use App\Models\UserDataScope;
use App\Models\Core\Branch;
use App\Models\Core\Department;
use App\Models\Core\Designation;
use App\Models\Core\Division;
use App\Models\Core\Location;
use App\Models\Core\Post;
use App\Models\Core\Vertical;
use App\Models\Core\UserType;
use Carbon\Carbon;
use Exception;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use PhpOffice\PhpSpreadsheet\IOFactory;

/**
 * UserImporter Service
 * 
 * Handles bulk import of users from Excel files
 * Creates Person â†’ Employee â†’ User hierarchy with all assignments
 * Supports data scoping, pivot assignments, and permission management
 */
class UserImporter
{
    private $filePath;
    private $sheetName = 'Users';
    private $errors = [];
    private $warnings = [];
    private $imported = 0;
    private $skipped = 0;
    private $startRow = 2; // Skip header row

    // Caches for performance
    private $designationCache = [];
    private $departmentCache = [];
    private $branchCache = [];
    private $locationCache = [];
    private $divisionCache = [];
    private $verticalCache = [];
    private $postCache = [];
    private $userTypeCache = [];

    public function __construct($filePath)
    {
        $this->filePath = $filePath;
    }

    /**
     * Execute the import process
     */
    public function execute()
    {
        try {
            $spreadsheet = IOFactory::load($this->filePath);
            $worksheet = $spreadsheet->getSheetByName($this->sheetName);

            // Get header row for column mapping
            $headers = $this->extractHeaders($worksheet);

            // Process each data row
            foreach ($worksheet->getRowIterator($this->startRow) as $row) {
                try {
                    $rowData = $this->extractRowData($row, $headers);

                    if (empty(array_filter($rowData))) {
                        $this->skipped++;
                        continue;
                    }

                    $this->processRow($rowData);
                    $this->imported++;
                } catch (Exception $e) {
                    $this->errors[] = [
                        'row' => $row->getRowIndex(),
                        'error' => $e->getMessage()
                    ];
                    $this->skipped++;
                }
            }

            return $this->getResult();
        } catch (Exception $e) {
            Log::error('User Import Failed', ['error' => $e->getMessage()]);
            throw new Exception("Import failed: " . $e->getMessage());
        }
    }

    /**
     * Extract headers from first row
     */
    private function extractHeaders($worksheet)
    {
        $headers = [];
        foreach ($worksheet->getRowIterator(1, 1) as $row) {
            foreach ($row->getCellIterator() as $cell) {
                $headers[] = trim($cell->getValue());
            }
        }
        return $headers;
    }

    /**
     * Extract data from a single row
     */
    private function extractRowData($row, $headers)
    {
        $data = [];
        $cellIterator = $row->getCellIterator();
        $colIndex = 0;

        foreach ($cellIterator as $cell) {
            if ($colIndex < count($headers)) {
                $key = $headers[$colIndex];
                $value = $cell->getValue();

                // Handle date values
                if ($value instanceof \DateTime) {
                    $value = $value->format('Y-m-d');
                }

                $data[$key] = trim((string)$value);
            }
            $colIndex++;
        }

        return $data;
    }

    /**
     * Process a single row - create Person, Employee, and User
     */
    private function processRow($rowData)
    {
        DB::beginTransaction();

        try {
            // Validate required fields
            $this->validateRequired($rowData);

            // Create or update Person
            $person = $this->createOrUpdatePerson($rowData);

            // Create or update Employee
            $employee = $this->createOrUpdateEmployee($person, $rowData);

            // Create or update User
            $user = $this->createOrUpdateUser($person, $employee, $rowData);

            // Create assignments (Branch, Department, Location, Division, Vertical, Post)
            $this->createAssignments($employee, $rowData);

            // Create user data scopes (for RBAC)
            $this->createDataScopes($user, $rowData);

            // Assign roles and permissions
            $this->assignRolesAndPermissions($user, $employee, $rowData);

            DB::commit();
        } catch (Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Validate required fields in row
     */
    private function validateRequired($rowData)
    {
        $required = [
            'First Name' => 'Person First Name',
            'Last Name' => 'Person Last Name',
            'Email' => 'Email Address',
            'Employee Code' => 'Employee Code',
            'Designation' => 'Designation',
            'Department' => 'Department',
            'Branch' => 'Branch',
            'Date of Joining' => 'Joining Date',
            'Username' => 'Username',
        ];

        foreach ($required as $key => $label) {
            if (empty($rowData[$key] ?? null)) {
                throw new Exception("Missing required field: $label");
            }
        }
    }

    /**
     * Create or update Person record
     */
    private function createOrUpdatePerson($rowData)
    {
        $email = $rowData['Email'] ?? null;
        $code = $rowData['Person Code'] ?? null;

        $personData = [
            'firstname' => $rowData['First Name'],
            'middlename' => $rowData['Middle Name'] ?? null,
            'lastname' => $rowData['Last Name'],
            'displayname' => trim($rowData['First Name'] . ' ' . ($rowData['Last Name'] ?? '')),
            'gender' => strtolower($rowData['Gender'] ?? 'other'),
            'dob' => $this->parseDate($rowData['Date of Birth'] ?? null),
            'maritalstatus' => $rowData['Marital Status'] ?? null,
            'emailprimary' => $email,
            'mobileprimary' => $rowData['Phone'] ?? null,
        ];

        // Find by email or code, or create new
        $person = Person::where('emailprimary', $email)->first();

        if (!$person) {
            $personData['code'] = $code ?? Person::generateCode();
            $person = Person::create($personData);
        } else {
            $person->update($personData);
        }

        return $person;
    }

    /**
     * Create or update Employee record
     */
    private function createOrUpdateEmployee($person, $rowData)
    {
        $empCode = $rowData['Employee Code'];
        $designation = $this->lookupDesignation($rowData['Designation']);
        $primaryDept = $this->lookupDepartment($rowData['Department']);
        $primaryBranch = $this->lookupBranch($rowData['Branch']);

        $employeeData = [
            'personid' => $person->id,
            'designationid' => $designation->id,
            'primarybranchid' => $primaryBranch->id,
            'primarydepartmentid' => $primaryDept->id,
            'joiningdate' => $this->parseDate($rowData['Date of Joining']),
            'employmenttype' => strtolower($rowData['Employment Type'] ?? 'permanent'),
            'employmentstatus' => $rowData['Employment Status'] ?? 'active',
            'isactive' => true,
        ];

        $employee = Employee::where('code', $empCode)->first();

        if (!$employee) {
            $employeeData['code'] = $empCode;
            $employee = Employee::create($employeeData);
        } else {
            $employee->update($employeeData);
        }

        return $employee;
    }

    /**
     * Create or update User record
     */
    private function createOrUpdateUser($person, $employee, $rowData)
    {
        $email = $rowData['Email Login'] ?? $rowData['Email'];
        $username = $rowData['Username'];
        $userType = $this->lookupUserType($rowData['User Type'] ?? 'Standard User');

        $userData = [
            'personid' => $person->id,
            'employeeid' => $employee->id,
            'usertypeid' => $userType->id,
            'code' => $username,
            'name' => $person->displayname,
            'email' => $email,
            'isactive' => $this->parseBoolean($rowData['User Status'] ?? 'Active'),
        ];

        $user = User::where('email', $email)->first();

        if (!$user) {
            // Generate temporary password
            $userData['password'] = bcrypt('TempPass@' . date('YmdHis'));
            $user = User::create($userData);
        } else {
            // Don't update password if user exists
            unset($userData['password']);
            $user->update($userData);
        }

        return $user;
    }

    /**
     * Create employee assignments (Branch, Department, Location, Division, Vertical, Post)
     */
    private function createAssignments($employee, $rowData)
    {
        $fromDate = $this->parseDate($rowData['Date of Joining']);

        // Branch Assignment
        if (!empty($rowData['Branch'])) {
            $branch = $this->lookupBranch($rowData['Branch']);
            $employee->branches()->syncWithoutDetaching([
                $branch->id => [
                    'fromdate' => $fromDate,
                    'isprimary' => true,
                    'iscurrent' => true,
                ]
            ]);
        }

        // Department Assignment
        if (!empty($rowData['Department'])) {
            $dept = $this->lookupDepartment($rowData['Department']);
            $employee->departments()->syncWithoutDetaching([
                $dept->id => [
                    'fromdate' => $fromDate,
                    'iscurrent' => true,
                ]
            ]);
        }

        // Location Assignment
        if (!empty($rowData['Location'])) {
            $location = $this->lookupLocation($rowData['Location']);
            $branch = $this->lookupBranch($rowData['Branch']);
            $employee->locations()->syncWithoutDetaching([
                $location->id => [
                    'branchid' => $branch->id,
                    'fromdate' => $fromDate,
                    'iscurrent' => true,
                ]
            ]);
        }

        // Division Assignment
        if (!empty($rowData['Division'])) {
            $division = $this->lookupDivision($rowData['Division']);
            $employee->divisions()->syncWithoutDetaching([
                $division->id => [
                    'fromdate' => $fromDate,
                    'iscurrent' => true,
                ]
            ]);
        }

        // Vertical Assignment
        if (!empty($rowData['Vertical'])) {
            $vertical = $this->lookupVertical($rowData['Vertical']);
            $employee->verticals()->syncWithoutDetaching([
                $vertical->id => [
                    'fromdate' => $fromDate,
                    'iscurrent' => true,
                ]
            ]);
        }

        // Post Assignment
        if (!empty($rowData['Post'])) {
            $post = $this->lookupPost($rowData['Post']);
            $employee->posts()->syncWithoutDetaching([
                $post->id => [
                    'fromdate' => $fromDate,
                    'assignmentorder' => 1,
                    'iscurrent' => true,
                ]
            ]);
        }
    }

    /**
     * Create user data scopes for RBAC
     */
    private function createDataScopes($user, $rowData)
    {
        $scopes = [];

        // Branch scope
        if (!empty($rowData['Accessible Branches'])) {
            $branches = array_map('trim', explode(',', $rowData['Accessible Branches']));
            foreach ($branches as $branchCode) {
                $branch = Branch::where('code', $branchCode)->first();
                if ($branch) {
                    $scopes[] = [
                        'userid' => $user->id,
                        'scopetype' => 'branch',
                        'scopevalue' => $branch->id,
                        'status' => 'active',
                    ];
                }
            }
        }

        // Department scope
        if (!empty($rowData['Accessible Departments'])) {
            $departments = array_map('trim', explode(',', $rowData['Accessible Departments']));
            foreach ($departments as $deptCode) {
                $dept = Department::where('code', $deptCode)->first();
                if ($dept) {
                    $scopes[] = [
                        'userid' => $user->id,
                        'scopetype' => 'department',
                        'scopevalue' => $dept->id,
                        'status' => 'active',
                    ];
                }
            }
        }

        // Location scope
        if (!empty($rowData['Accessible Locations'])) {
            $locations = array_map('trim', explode(',', $rowData['Accessible Locations']));
            foreach ($locations as $locCode) {
                $location = Location::where('code', $locCode)->first();
                if ($location) {
                    $scopes[] = [
                        'userid' => $user->id,
                        'scopetype' => 'location',
                        'scopevalue' => $location->id,
                        'status' => 'active',
                    ];
                }
            }
        }

        if (!empty($scopes)) {
            UserDataScope::insert($scopes);
        }
    }

    /**
     * Assign roles and permissions based on post/designation
     */
    private function assignRolesAndPermissions($user, $employee, $rowData)
    {
        // Assign role based on User Type
        $userType = $rowData['User Type'] ?? 'Standard User';
        $roleMap = [
            'Super Admin' => 'superadmin',
            'Foundation Manager' => 'foundationmanager',
            'User Manager' => 'usermanager',
            'Vehicle Manager' => 'vehiclemanager',
            'Standard User' => 'user',
        ];

        $role = $roleMap[$userType] ?? 'user';
        $user->assignRole($role);

        // Assign role-based permissions automatically (via Spatie)
        // The role will automatically have its associated permissions
    }

    /**
     * Lookup helpers with caching
     */
    private function lookupDesignation($code)
    {
        if (!isset($this->designationCache[$code])) {
            $designation = Designation::where('code', $code)->first();
            if (!$designation) {
                throw new Exception("Designation not found: $code");
            }
            $this->designationCache[$code] = $designation;
        }
        return $this->designationCache[$code];
    }

    private function lookupDepartment($code)
    {
        if (!isset($this->departmentCache[$code])) {
            $dept = Department::where('code', $code)->first();
            if (!$dept) {
                throw new Exception("Department not found: $code");
            }
            $this->departmentCache[$code] = $dept;
        }
        return $this->departmentCache[$code];
    }

    private function lookupBranch($code)
    {
        if (!isset($this->branchCache[$code])) {
            $branch = Branch::where('code', $code)->first();
            if (!$branch) {
                throw new Exception("Branch not found: $code");
            }
            $this->branchCache[$code] = $branch;
        }
        return $this->branchCache[$code];
    }

    private function lookupLocation($code)
    {
        if (!isset($this->locationCache[$code])) {
            $location = Location::where('code', $code)->first();
            if (!$location) {
                throw new Exception("Location not found: $code");
            }
            $this->locationCache[$code] = $location;
        }
        return $this->locationCache[$code];
    }

    private function lookupDivision($code)
    {
        if (!isset($this->divisionCache[$code])) {
            $division = Division::where('code', $code)->first();
            if (!$division) {
                throw new Exception("Division not found: $code");
            }
            $this->divisionCache[$code] = $division;
        }
        return $this->divisionCache[$code];
    }

    private function lookupVertical($code)
    {
        if (!isset($this->verticalCache[$code])) {
            $vertical = Vertical::where('code', $code)->first();
            if (!$vertical) {
                throw new Exception("Vertical not found: $code");
            }
            $this->verticalCache[$code] = $vertical;
        }
        return $this->verticalCache[$code];
    }

    private function lookupPost($code)
    {
        if (!isset($this->postCache[$code])) {
            $post = Post::where('code', $code)->first();
            if (!$post) {
                throw new Exception("Post not found: $code");
            }
            $this->postCache[$code] = $post;
        }
        return $this->postCache[$code];
    }

    private function lookupUserType($name)
    {
        if (!isset($this->userTypeCache[$name])) {
            $userType = UserType::where('name', $name)->first();
            if (!$userType) {
                // Create default if not exists
                $userType = UserType::create(['name' => $name]);
            }
            $this->userTypeCache[$name] = $userType;
        }
        return $this->userTypeCache[$name];
    }

    /**
     * Helper: Parse date string to proper format
     */
    private function parseDate($dateString)
    {
        if (empty($dateString)) {
            return null;
        }

        try {
            return Carbon::createFromFormat('Y-m-d', $dateString)->toDateString();
        } catch (Exception $e) {
            try {
                return Carbon::createFromFormat('d-m-Y', $dateString)->toDateString();
            } catch (Exception $e2) {
                return null;
            }
        }
    }

    /**
     * Helper: Parse boolean from string
     */
    private function parseBoolean($value)
    {
        $truthy = ['yes', 'true', '1', 'active', 'on'];
        return in_array(strtolower($value), $truthy);
    }

    /**
     * Get import result
     */
    public function getResult()
    {
        return [
            'success' => count($this->errors) === 0,
            'imported' => $this->imported,
            'skipped' => $this->skipped,
            'errors' => $this->errors,
            'warnings' => $this->warnings,
            'message' => sprintf(
                'Import completed: %d users imported, %d skipped',
                $this->imported,
                $this->skipped
            ),
        ];
    }
}
///////End-of-File : UserImporter.php

File : VehicleDefineImporter.php
/////////Content of file VehicleDefineImporter.php
<?php

namespace App\Imports;

use App\Facades\KeywordValue;
use App\Models\Core\Brand;
use App\Models\Core\Color;
use App\Models\Core\Segment;
use App\Models\Core\SubSegment;
use App\Models\Core\Variant;
use App\Models\Core\VehicleModel;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use Maatwebsite\Excel\Concerns\ToCollection;
use Maatwebsite\Excel\Concerns\WithCalculatedFormulas;

/**
 * VehicleDefineImporter - Import vehicle definitions from Excel
 * 
 * IMPORTANT: VehicleModel is unique by Brand_id only, not by Segment!
 * This means ALFA LOAD DUO should exist only ONCE per brand,
 * regardless of how many segments/variants it appears in.
 */
class VehicleDefineImporter implements ToCollection, WithCalculatedFormulas
{
    private $rowCount = 0;
    private $skipped = 0;
    private array $headings = [];
    private array $created = [
        'brands' => 0,
        'segments' => 0,
        'sub_segments' => 0,
        'vehicle_models' => 0,
        'variants' => 0,
        'colors' => 0,
        'variant_colors' => 0,
    ];
    private array $errors = [];

    public function headings(): array
    {
        return $this->headings;
    }

    public function collection(Collection $rows)
    {
        echo "\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        echo "            VEHICLE DEFINITION IMPORT - STARTED\n";
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

        DB::beginTransaction();
        try {
            foreach ($rows as $key => $row) {
                $this->rowCount++;

                // Skip header row
                if ($key === 0) {
                    $this->headings = $row->toArray();
                    continue;
                }

                // Convert to associative array
                $data = $this->mapRowToArray($row);

                // Skip rows without Model Code
                if (empty($data['Model Code'])) {
                    $this->skipped++;
                    continue;
                }

                try {
                    $this->processRow($data);
                } catch (\Exception $e) {
                    $this->errors[] = [
                        'row' => $this->rowCount,
                        'model_code' => $data['Model Code'] ?? 'UNKNOWN',
                        'error' => $e->getMessage(),
                    ];
                    echo "âŒ ROW {$this->rowCount}: {$data['Model Code']} - {$e->getMessage()}\n";
                }
            }

            DB::commit();
            $this->displaySummary();
        } catch (\Exception $e) {
            DB::rollBack();
            echo "\nâŒ FATAL ERROR: {$e->getMessage()}\n";
            throw $e;
        }
    }

    private function mapRowToArray(Collection $row): array
    {
        $data = [];
        foreach ($this->headings as $index => $heading) {
            $data[$heading] = $row[$index] ?? null;
        }
        // print_r($data);
        return $data;
    }

    private function processRow(array $data): void
    {
        // 1. Brand
        $brand = $this->getOrCreateBrand();
        if (!$brand) {
            throw new \Exception("Brand creation failed");
        }

        // 2. Segment
        $segment = $this->getOrCreateSegment($brand, $data);
        if (!$segment) {
            throw new \Exception("Segment creation failed");
        }

        // 3. SubSegment (optional)
        $subSegment = null;
        if (!empty($data['Sub Segment'])) {
            $subSegment = $this->getOrCreateSubSegment($segment, $data);
        }

        // 4. VehicleModel - UNIQUE BY BRAND_ID ONLY!
        $vehicleModel = $this->getOrCreateVehicleModel($brand, $segment, $subSegment, $data);
        if (!$vehicleModel) {
            throw new \Exception("VehicleModel creation failed");
        }

        // 5. Color
        $color = $this->getOrCreateColor($brand, $segment, $subSegment, $vehicleModel, $data);
        if (!$color) {
            throw new \Exception("Color creation failed");
        }

        // 6. Variant
        $variant = $this->createVariant($brand, $segment, $subSegment, $vehicleModel, $data);
        if (!$variant) {
            throw new \Exception("Variant creation failed");
        }

        // 7. Variant-Color Mapping
        $this->createOrUpdateVariantColor($variant, $color);
    }

    private function getOrCreateBrand(): ?Brand
    {
        $brandName = "Mahindra";
        $brandCode = "MHND";

        $brand = Brand::where('code', strtoupper($brandCode))->first();

        if (!$brand) {
            $brand = Brand::create([
                'name' => json_encode(['en' => $brandName]),
                'code' => strtoupper($brandCode),
                'is_active' => true,
            ]);
            $this->created['brands']++;
        }

        return $brand;
    }

    private function getOrCreateSegment(Brand $brand, array $data): ?Segment
    {
        $segmentName = $data['Segment'] ?? null;

        if (empty($segmentName)) {
            return null;
        }

        // Auto-generate segment code
        $segmentCode = strtoupper(str_replace(' ', '', $segmentName));

        // Check if exists (brand + code)
        $segment = Segment::where('brand_id', $brand->id)
            ->where('code', $segmentCode)
            ->first();

        if ($segment) {
            return $segment;
        }

        // Create new
        $segment = Segment::create([
            'brand_id' => $brand->id,
            'name' => json_encode(['en' => trim($segmentName)]),
            'code' => $segmentCode,
            'is_active' => true,
        ]);

        $this->created['segments']++;
        return $segment;
    }

    private function getOrCreateSubSegment(Segment $segment, array $data): ?SubSegment
    {
        $subSegmentName = $data['Sub Segment'] ?? null;

        if (empty($subSegmentName)) {
            return null;
        }

        $subSegmentCode = strtoupper(str_replace(' ', '', $subSegmentName));

        // Check if exists
        $subSegment = SubSegment::where('segment_id', $segment->id)
            ->where('code', $subSegmentCode)
            ->first();

        if ($subSegment) {
            return $subSegment;
        }

        // Create new
        $subSegment = SubSegment::create([
            'segment_id' => $segment->id,
            'name' => json_encode(['en' => trim($subSegmentName)]),
            'code' => $subSegmentCode,
            'is_active' => true,
        ]);

        $this->created['sub_segments']++;
        return $subSegment;
    }

    /**
     * Get or create VehicleModel
     * 
     * CRITICAL: VehicleModel is unique by Brand_id ONLY!
     * Not by Segment. Multiple rows can have same model name
     * if they're the same brand (even different segments).
     * 
     * This prevents duplicates like:
     * ALFA LOAD DUO appearing 6 times with same brand_id+segment
     */
    private function getOrCreateVehicleModel(
        Brand $brand,
        Segment $segment,
        ?SubSegment $subSegment,
        array $data
    ): ?VehicleModel {
        $oemModel = $data['OEM Model'] ?? null;
        $customModel = $data['Custom Model'] ?? null;

        if (empty($oemModel)) {
            return null;
        }

        // Check if model exists BY BRAND ONLY
        // NOT by segment! This is the KEY FIX!
        $vehicleModel = VehicleModel::where('brand_id', $brand->id)
            ->where('segment_id', $segment->id)
            ->where('name', trim($oemModel))
            ->first();
        //print_r($vehicleModel);

        if ($vehicleModel) {
            // Model exists - update custom_name if provided and different
            if (!empty($customModel) && $vehicleModel->custom_name !== trim($customModel)) {
                $vehicleModel->update(['custom_name' => trim($customModel)]);
            }
            return $vehicleModel;
        }

        // Create new model
        $vehicleModel = VehicleModel::create([
            'brand_id' => $brand->id,
            'segment_id' => $segment->id,
            'sub_segment_id' => $subSegment?->id,
            'name' => trim($oemModel),
            'custom_name' => !empty($customModel) ? trim($customModel) : null,
            'is_active' => true,
        ]);

        $this->created['vehicle_models']++;
        return $vehicleModel;
    }

    private function getOrCreateColor(
        Brand $brand,
        Segment $segment,
        ?SubSegment $subSegment,
        VehicleModel $vehicleModel,
        array $data
    ): ?Color {
        $colorName = $data['Colour'] ?? null;
        $colorCode = $data['Colour Code'] ?? null;

        if ($colorName == "#N/A") {
            $colorName = $colorCode;
        }

        if (empty($colorName)) {
            return null;
        }

        $colorCodeUpper = strtoupper($colorCode ?? $colorName);

        // Check if exists (by model + code)
        $color = Color::where('vehicle_model_id', $vehicleModel->id)
            ->where('code', $colorCodeUpper)
            ->first();

        if ($color) {
            return $color;
        }

        // Create new
        $color = Color::create([
            'brand_id' => $brand->id,
            'segment_id' => $segment->id,
            'sub_segment_id' => $subSegment?->id,
            'vehicle_model_id' => $vehicleModel->id,
            'name' =>  trim($colorName),
            'code' => $colorCodeUpper,
            'is_active' => true,
        ]);

        $this->created['colors']++;
        return $color;
    }

    private function createVariant(
        Brand $brand,
        Segment $segment,
        ?SubSegment $subSegment,
        VehicleModel $vehicleModel,
        array $data
    ): ?Variant {
        $oemVariant = $data['OEM Variant'] ?? null;
        $customVariant = $data['Custom Variant'] ?? null;
        $oemCode = $data['Model Code'] ?? null;
        $tOemCode = substr(trim($oemCode), 0, -2);
        if (empty($oemVariant) || empty($oemCode)) {
            return null;
        }

        // Check if variant already exists by oem_code
        $existingVariant = Variant::where('oem_code', $tOemCode)->first();
        if ($existingVariant) {
            return $existingVariant;
        }

        $variantData = [
            'brand_id' => $brand->id,
            'segment_id' => $segment->id,
            'sub_segment_id' => $subSegment?->id,
            'vehicle_model_id' => $vehicleModel->id,
            'name' => trim($oemVariant),
            'custom_name' => !empty($customVariant) ? trim($customVariant) : null,
            'oem_code' => $tOemCode,
            'is_active' => true,
        ];

        // Add specs using KeywordValue service
        if (!empty($data['Fuel'])) {
            $fuelId = KeywordValue::findValueId('fuel_type', trim($data['Fuel']));
            if ($fuelId) {
                $variantData['fuel_type_id'] = $fuelId;
            }
        }

        if (!empty($data['Seating'])) {
            $variantData['seating_capacity'] = (int) $data['Seating'];
        }

        if (!empty($data['Wheels'])) {
            $variantData['wheels'] = (int) $data['Wheels'];
        }

        if (!empty($data['CC'])) {
            $variantData['cc_capacity'] = trim($data['CC']);
        }

        if (!empty($data['GVW'])) {
            $variantData['gvwr'] = (int) $data['GVW'];
        }

        if (!empty($data['Body Make'])) {
            $makeId = KeywordValue::findValueId('body_make', trim($data['Body Make']));
            if ($makeId) {
                $variantData['body_make_id'] = $makeId;
            }
        }

        if (!empty($data['Body Type'])) {
            $typeId = KeywordValue::findValueId('body_type', trim($data['Body Type']));
            if ($typeId) {
                $variantData['body_type_id'] = $typeId;
            }
        }

        if (!empty($data['Permit'])) {
            $permitId = KeywordValue::findValueId('permit', trim($data['Permit']));
            if ($permitId) {
                $variantData['permit_id'] = $permitId;
            }
        }

        if (empty($data['Status']))
            $data['Status'] = "ACTIVE";
        else
            $data['Status'] = trim(strtoupper($data['Status']));

        $statusId = KeywordValue::findValueId('vehicle_status', $data['Status']);
        if ($statusId) {
            $variantData['status_id'] = $statusId;
            if ($data['Status'] == "ACTIVE")
                $variantData['is_active'] = true;
            else
                $variantData['is_active'] = false;
        }
        //print_r($variantData);
        $variant = Variant::create($variantData);
        //print_r($variant->toarray());
        $this->created['variants']++;
        return $variant;
    }

    private function createOrUpdateVariantColor(Variant $variant, Color $color): void
    {
        // Check if mapping exists
        $mapping = DB::table('variant_colors')
            ->where('variant_id', $variant->id)
            ->where('color_id', $color->id)
            ->first();

        if (!$mapping) {
            DB::table('variant_colors')->insert([
                'variant_id' => $variant->id,
                'color_id' => $color->id,
                'created_at' => now(),
                'updated_at' => now(),
            ]);
            $this->created['variant_colors']++;
        }
    }

    private function displaySummary(): void
    {
        echo "\n";
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        echo "                  IMPORT COMPLETED\n";
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";

        echo "ðŸ“Š SUMMARY:\n";
        echo "   Total Rows Processed:    {$this->rowCount}\n";
        echo "   Rows Skipped:            {$this->skipped}\n";
        echo "   Successfully Imported:   " . ($this->rowCount - $this->skipped) . "\n\n";

        if (count($this->errors) > 0) {
            echo "âš ï¸  ERRORS OCCURRED:\n";
            foreach ($this->errors as $error) {
                echo "   â€¢ Row {$error['row']} ({$error['model_code']}): {$error['error']}\n";
            }
            echo "\n";
        }

        echo "ðŸ“ˆ CREATED:\n";
        echo "   Brands:                  {$this->created['brands']}\n";
        echo "   Segments:                {$this->created['segments']}\n";
        echo "   Sub-Segments:            {$this->created['sub_segments']}\n";
        echo "   Vehicle Models:          {$this->created['vehicle_models']}\n";
        echo "   Variants:                {$this->created['variants']}\n";
        echo "   Colors:                  {$this->created['colors']}\n";
        echo "   Variant-Color Mappings:  {$this->created['variant_colors']}\n\n";

        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    }
}
///////End-of-File : VehicleDefineImporter.php

Folder : d:\xampp\htdocs\vdms\app\.\Models

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Models

File : BaseModel.php
/////////Content of file BaseModel.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use OwenIt\Auditing\Contracts\Auditable;
use OwenIt\Auditing\Auditable as AuditableTrait;
use Spatie\MediaLibrary\HasMedia;
use Spatie\MediaLibrary\InteractsWithMedia;
use Spatie\Translatable\HasTranslations;
use App\Models\Traits\HasAuditFields;
use App\Models\Traits\HasSlug;
use App\Models\Traits\HasColumnTransformations;
use App\Models\Traits\HasTreeStructure;

/**
 * BaseModel - Foundation model for all VDMS models
 * 
 * Features:
 * - Soft deletes for data safety
 * - Audit trail tracking (created_by, updated_by, deleted_by)
 * - Media library integration (file uploads)
 * - Automatic timestamp handling
 * - Common scopes and relationships
 * - Translations
 * - Tree structure
 * - Slug generation
 * - Column transformations
 */
abstract class BaseModel extends Model implements Auditable, HasMedia
{
    use SoftDeletes;
    use AuditableTrait;
    use InteractsWithMedia;
    use HasTranslations;
    use HasAuditFields;
    // use HasSlug;
    //use HasTreeStructure;
    use HasColumnTransformations;
    //use FilterByDataScope;
    //use HasTreeStructure;

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
        'extra_data' => 'array',
        'is_active' => 'boolean',
    ];

    public $translatable = [];

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $guarded = ['id'];

    /**
     * Enable timestamps
     *
     * @var bool
     */
    public $timestamps = true;

    protected static function booted()
    {
        // $user = auth()->user();

        // //  Rule 1: SuperAdmin must NEVER be scoped
        // if ($user && method_exists($user, 'isSuperAdmin') && $user->isSuperAdmin()) {
        //     return; // Do NOT add FilterByDataScope at all
        // }

        // //  Rule 2: Only models with $scopeType are scoped
        // if (property_exists(static::class, 'scopeType')) {
        //     static::addGlobalScope(new \App\Models\Traits\FilterByDataScope());
        // }
    }

    /**
     * Get audit trail history
     */
    public function getHistory($limit = 50)
    {
        return $this->audits()
            ->orderByDesc('created_at')
            ->limit($limit)
            ->get()
            ->map(function ($audit) {
                return [
                    'id' => $audit->id,
                    'event' => $audit->event,
                    'user' => $audit->user?->name ?? 'System',
                    'changes' => $audit->getModified(),
                    'created_at' => $audit->created_at->format('Y-m-d H:i:s'),
                ];
            });
    }

    /**
     * Register media collections for file uploads
     */
    public function registerMediaCollections(): void
    {
        $this->addMediaCollection('documents')
            ->acceptsMimeTypes(['application/pdf', 'image/jpeg', 'image/png', 'application/msword'])
            ->useDisk('public');

        $this->addMediaCollection('photos')
            ->acceptsMimeTypes(['image/jpeg', 'image/png', 'image/gif'])
            ->useDisk('public');

        $this->addMediaCollection('attachments')
            ->useDisk('public');
    }

    /**
     * Scope: Get only active records
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true)->whereNull('deleted_at');
    }

    /**
     * Scope: Get only inactive records
     */
    public function scopeInactive($query)
    {
        return $query->where('is_active', false);
    }

    /**
     * Scope: Get only deleted records
     */
    public function scopeDeleted($query)
    {
        return $query->whereNotNull('deleted_at');
    }

    /**
     * Scope: Get all records including deleted (for admin)
     */
    public function scopeWithDeleted($query)
    {
        return $query->withTrashed();
    }

    /**
     * Scope: Order by created date newest first
     */
    public function scopeNewest($query)
    {
        return $query->orderByDesc('created_at');
    }

    /**
     * Scope: Order by created date oldest first
     */
    public function scopeOldest($query)
    {
        return $query->orderBy('created_at');
    }
}
///////End-of-File : BaseModel.php

File : s
/////////Content of file s
///////End-of-File : s

File : User.php
/////////Content of file User.php
<?php

namespace App\Models;

use Backpack\CRUD\app\Models\Traits\CrudTrait;
use App\Models\Core\Employee;
use App\Models\Core\Person;
use App\Models\Core\UserType;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;
use OwenIt\Auditing\Contracts\Auditable;
use OwenIt\Auditing\Auditable as AuditableTrait;
use Spatie\Permission\Traits\HasRoles;
use App\Models\Core\ReportingHierarchy;
use App\Models\Core\ApprovalHierarchy;

/**
 * User Model
 * 
 * Application user authentication and authorization
 * Extended with person linkage, employee linkage, role management, and hierarchical data scoping
 */
class User extends Authenticatable implements Auditable
{
    use HasFactory;
    use Notifiable;
    use HasApiTokens;
    use HasRoles;
    use SoftDeletes;
    use AuditableTrait;
    use CrudTrait;

    protected $fillable = [
        'person_id',
        'employee_id',
        'user_type_id',
        'code',
        'name',
        'email',
        'password',
        'avatar',
        'phone',
        'is_active',
        'last_login_at',
        'email_verified_at',
        'remember_token',
        'mile_id',
    ];

    protected $hidden = [
        'password',
        'remember_token',
    ];

    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
        'is_active' => 'boolean',
        'last_login_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Guard for roles/permissions
     */
    protected $guard_name = 'web';

    /**
     * Boot: Auto-set audit fields
     */
    public static function boot()
    {
        parent::boot();

        static::creating(function ($model) {
            if (auth()->check() && !$model->created_by) {
                $model->created_by = auth()->id();
            }
        });

        static::updating(function ($model) {
            if (auth()->check()) {
                $model->updated_by = auth()->id();
            }
        });

        static::deleting(function ($model) {
            if (!$model->isForceDeleting()) {
                if (auth()->check()) {
                    $model->deleted_by = auth()->id();
                    $model->save();
                }
            }
        });
    }

    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘        EXISTING RELATIONSHIPS (Preserved)              â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Relationship: Person record
     */
    public function person(): BelongsTo
    {
        return $this->belongsTo(Person::class);
    }

    /**
     * Relationship: Employee record
     */
    public function employee(): BelongsTo
    {
        return $this->belongsTo(Employee::class);
    }

    /**
     * Relationship: User type
     */
    public function userType(): BelongsTo
    {
        return $this->belongsTo(UserType::class);
    }

    /**
     * Relationship: Role assignments
     */
    public function roleAssignments()
    {
        return $this->hasMany(\App\Models\Core\UserRoleAssignment::class);
    }

    /**
     * Relationship: Division assignments
     */
    public function divisionAssignments()
    {
        return $this->hasMany(\App\Models\Core\UserDivisionAssignment::class);
    }

    /**
     * Relationship: Current roles
     */
    public function currentRoles()
    {
        return $this->roles()
            ->whereIn('roles.id', function ($query) {
                $query->selectRaw('role_id')
                    ->from('user_role_assignments')
                    ->where('user_id', $this->id)
                    ->where('is_current', true)
                    ->where(function ($q) {
                        $q->whereNull('to_date')
                            ->orWhere('to_date', '>=', now());
                    });
            });
    }

    /**
     * Relationship: Current divisions
     */
    public function currentDivisions()
    {
        return $this->divisionAssignments()
            ->where('is_current', true)
            ->where(function ($q) {
                $q->whereNull('to_date')
                    ->orWhere('to_date', '>=', now());
            });
    }

    /**
     * Relationship: Enquiries
     */
    public function enquiries()
    {
        return $this->hasMany(Enquiry::class, 'mile_id');
    }

    /**
     * Relationship: Quotes
     */
    public function quotes()
    {
        return $this->hasMany(Quote::class, 'mile_id');
    }

    /**
     * Relationship: Bookings
     */
    public function bookings()
    {
        return $this->hasMany(Booking::class, 'mile_id');
    }

    /**
     * Relationship: Sales
     */
    public function sales()
    {
        return $this->hasMany(Sale::class, 'mile_id');
    }

    /**
     * Relationship: GraphNode
     */
    public function graphNode()
    {
        return $this->hasOne(\App\Models\Core\GraphNode::class);
    }

    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘     NEW: HIERARCHICAL DATA SCOPING (Added Methods)     â•‘
    // â•‘     Does NOT break any existing functionality           â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Relationship: User's assigned data scopes
     * 
     * Table: user_data_scopes
     * Stores: user_id, scope_type (branch|location|dept|etc), scope_value (ID or NULL for wildcard)
     * 
     * @return HasMany
     */
    public function userDataScopes(): HasMany
    {
        return $this->hasMany(\App\Models\UserDataScope::class);
    }

    /**
     * Get active scopes only
     * 
     * @return HasMany
     */
    public function getActiveScopes(): HasMany
    {
        return $this->userDataScopes()->where('status', 'active');
    }

    /**
     * Get user's scope access for a specific type
     * 
     * Returns:
     *   null        â†’ Wildcard (all instances of this type)
     *   []          â†’ No access to this type
     *   [1, 5, 10]  â†’ Specific IDs only
     * 
     * @param string $scopeType (branch, location, department, etc.)
     * @return array|null
     */
    // User.php
    public function getScopeAccess(string $scopeType): array|null
    {
        // Not strictly required anymore for scoping, but safe:
        if ($this->isSuperAdmin()) {
            return null; // wildcard, but scope will not be attached anyway
        }

        $scopes = $this->getActiveScopes()
            ->where('scope_type', $scopeType)
            ->pluck('scope_value')
            ->all();

        if (empty($scopes)) {
            return [];          // no access for that type
        }

        if (in_array(null, $scopes, true)) {
            return null;        // wildcard
        }

        return array_filter($scopes); // specific IDs
    }


    /**
     * Check if user has access to specific entity
     * SuperAdmin automatically has access to everything
     * 
     * @param string $scopeType
     * @param int|null $entityId
     * @return bool
     */
    public function hasAccessTo(string $scopeType, int|null $entityId = null): bool
    {
        // âœ… SuperAdmin has access to everything
        if ($this->isSuperAdmin()) {
            return true;
        }

        $allowedValues = $this->getScopeAccess($scopeType);

        // No scope assigned = no access
        if ($allowedValues === []) {
            return false;
        }

        // Wildcard (null in database) = access to everything
        if ($allowedValues === null) {
            return true;
        }

        // Check if user's entity ID is in allowed list
        if ($entityId === null) {
            return false;
        }

        return in_array($entityId, $allowedValues);
    }


    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘        SCOPE ACCESS HELPERS (by entity type)           â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Get all branch IDs user has access to
     * @return array|null  â†’ array of IDs, null for wildcard, empty for no access
     */
    public function getAccessibleBranches(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }

        return $this->getScopeAccess('branch');
    }

    /**
     * Get all location IDs user has access to
     */
    public function getAccessibleLocations(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('location');
    }

    /**
     * Get all department IDs user has access to
     */
    public function getAccessibleDepartments(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('department');
    }

    /**
     * Get all division IDs user has access to
     */
    public function getAccessibleDivisions(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('division');
    }

    /**
     * Get all vertical IDs user has access to
     */
    public function getAccessibleVerticals(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('vertical');
    }

    /**
     * Get all brand IDs user has access to
     */
    public function getAccessibleBrands(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('brand');
    }

    /**
     * Get all segment IDs user has access to
     */
    public function getAccessibleSegments(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('segment');
    }

    /**
     * Get all sub-segment IDs user has access to
     */
    public function getAccessibleSubSegments(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('sub_segment');
    }

    /**
     * Get all vehicle model IDs user has access to
     */
    public function getAccessibleVehicleModels(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('vehicle_model');
    }

    /**
     * Get all variant IDs user has access to
     */
    public function getAccessibleVariants(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('variant');
    }

    /**
     * Get all color IDs user has access to
     */
    public function getAccessibleColors(): array|null
    {
        if ($this->isSuperAdmin()) {
            return null;  // wildcard
        }
        return $this->getScopeAccess('color');
    }

    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘     EXISTING METHODS (Preserved & Enhanced)            â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Get user scope (branches, departments, locations, etc.)
     * 
     * UPDATED: Now includes data scoping information
     * BACKWARD COMPATIBLE: Existing logic still works
     */
    public function getScope()
    {
        if ($this->hasRole('super_admin|admin')) {
            return [
                'all_access' => true,
            ];
        }

        if ($this->employee) {
            $scope = $this->employee->getCurrentScope();

            // Merge with data scopes if any
            $dataScopes = [
                'branches' => $this->getAccessibleBranches(),
                'locations' => $this->getAccessibleLocations(),
                'departments' => $this->getAccessibleDepartments(),
                'divisions' => $this->getAccessibleDivisions(),
                'verticals' => $this->getAccessibleVerticals(),
                'brands' => $this->getAccessibleBrands(),
                'segments' => $this->getAccessibleSegments(),
            ];

            return array_merge($scope, ['data_scopes' => $dataScopes]);
        }

        return [];
    }

    /**
     * Check if user has all required permissions
     */
    public function hasAllPermissions($permissions)
    {
        if (is_string($permissions)) {
            $permissions = [$permissions];
        }

        foreach ($permissions as $permission) {
            if (!$this->hasPermissionTo($permission)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Check if user has any of the permissions
     */
    public function hasAnyPermission($permissions)
    {
        if (is_string($permissions)) {
            $permissions = [$permissions];
        }

        foreach ($permissions as $permission) {
            if ($this->hasPermissionTo($permission)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Check if user is super admin
     * UPDATED: Now supports both 'super_admin' and 'super-admin' naming conventions
     */
    public function isSuperAdmin(): bool
    {
        return $this->hasRole(['super_admin', 'super-admin', 'SuperAdmin']);
    }

    /**
     * Check if user is sales consultant
     */
    public function isSalesConsultant(): bool
    {
        return $this->hasRole('Sales_Consultant');
    }

    /**
     * Enhanced permission check with SuperAdmin bypass
     * 
     * SuperAdmin automatically gets true, others checked against permissions
     */
    public function can($abilities, $arguments = []): bool
    {
        // SuperAdmin bypass - can do anything
        if ($this->isSuperAdmin()) {
            return true;
        }

        // Default: use parent class implementation (Spatie permissions)
        return parent::can($abilities, $arguments);
    }

    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘         EXISTING SCOPES (Preserved)                    â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Scope: Only active users
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true)->whereNull('deleted_at');
    }

    /**
     * Scope: Only employees
     */
    public function scopeEmployees($query)
    {
        return $query->whereNotNull('employee_id');
    }

    /**
     * Scope: Only admins
     */
    public function scopeAdmins($query)
    {
        return $query->whereHas('roles', function ($q) {
            $q->whereIn('name', ['super_admin', 'admin']);
        });
    }

    /**
     * Scope: Search users
     */
    public function scopeSearch($query, $term)
    {
        return $query->where('name', 'like', "%{$term}%")
            ->orWhere('email', 'like', "%{$term}%")
            ->orWhere('code', 'like', "%{$term}%");
    }

    // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    // â•‘         EXISTING HELPER METHODS (Preserved)            â•‘
    // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Update last login timestamp
     */
    public function recordLogin()
    {
        $this->update(['last_login_at' => now()]);
    }

    /**
     * Generate auto code
     */
    public static function generateCode()
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return 'USR-' . str_pad($lastId + 1, 6, '0', STR_PAD_LEFT);
    }

    /**
     * Get user display name
     */
    public function getDisplayNameAttribute()
    {
        return $this->person?->display_name ?? $this->name;
    }

    /**
     * Get user avatar URL
     */
    public function getAvatarUrlAttribute()
    {
        if ($this->avatar) {
            return asset('storage/' . $this->avatar);
        }

        return asset('images/default-avatar.png');
    }


    // In User.php, add:
    public function approvalHierarchies()
    {
        return $this->hasMany(ApprovalHierarchy::class, 'approver_id');
    }

    public function reportingHierarchies()
    {
        return $this->hasMany(ReportingHierarchy::class);
    }

    public function subordinates()
    {
        return $this->hasMany(ReportingHierarchy::class, 'supervisor_id');
    }

    // Performance aggregate
    public function aggregatePerformance(string $topic, array $combo, string $metric, $from = null, $to = null): float
    {
        $reportingRoot = $this->reportingHierarchies()->where('topic', $topic)->whereJsonContains('combo_json', $combo)->first();
        if (!$reportingRoot) return 0.0;

        $userIds = $reportingRoot->getSubtreeUserIds($topic, $combo);

        // Example for bookings (adapt for quotes/enquiries)
        //$query = Booking::whereIn('created_by', $userIds)->where('topic', $topic)->whereJsonContains('combo_json', $combo);
        // if ($from && $to) $query->whereBetween('created_at', [$from, $to]);

        // return match ($metric) {
        //     'count' => $query->count(),
        //     'value' => $query->sum('amount'),
        //     default => 0.0,
        // };
    }
}
///////End-of-File : User.php

File : UserDataScope.php
/////////Content of file UserDataScope.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

/**
 * User Data Scope Model
 * 
 * Represents the scope of data a user can access
 * 
 * Example:
 * user_id: 1, scope_type: 'branch', scope_value: 5
 * = User 1 can access Branch 5
 * 
 * user_id: 1, scope_type: 'branch', scope_value: null
 * = User 1 can access ALL branches (wildcard)
 */
class UserDataScope extends Model
{
    use SoftDeletes;

    protected $table = 'user_data_scopes';

    protected $fillable = [
        'user_id',
        'scope_type',
        'scope_value',
        'hierarchy_level',
        'status',
    ];

    protected $casts = [
        'hierarchy_level' => 'integer',
        'scope_value' => 'integer',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: User
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Scope: Only active scopes
     */
    public function scopeActive($query)
    {
        return $query->where('status', 'active')->whereNull('deleted_at');
    }

    /**
     * Scope: By scope type
     */
    public function scopeByType($query, string $type)
    {
        return $query->where('scope_type', $type);
    }

    /**
     * Scope: By user
     */
    public function scopeForUser($query, int $userId)
    {
        return $query->where('user_id', $userId);
    }

    /**
     * Check if this scope is a wildcard (null = all instances)
     */
    public function isWildcard(): bool
    {
        return is_null($this->scope_value);
    }

    /**
     * Get display name for scope
     */
    public function getDisplayName(): string
    {
        if ($this->isWildcard()) {
            return "All {$this->scope_type}s";
        }

        $model = $this->getScopeModel();
        $instance = $model::find($this->scope_value);

        return $instance?->name ?? "Unknown {$this->scope_type}";
    }

    /**
     * Get the model class for this scope type
     */
    private function getScopeModel(): string
    {
        return match ($this->scope_type) {
            'branch' => Branch::class,
            'location' => Location::class,
            'department' => Department::class,
            'vertical' => Vertical::class,
            'segment' => Segment::class,
            'brand' => Brand::class,
            default => throw new \InvalidArgumentException("Unknown scope type: {$this->scope_type}"),
        };
    }
}
///////End-of-File : UserDataScope.php

Folder : d:\xampp\htdocs\vdms\app\.\Models\Core

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Models\Core

File : AccountLock.php
/////////Content of file AccountLock.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;

class AccountLock extends BaseModel
{
    protected $fillable = [
        'user_id',
        'locked_until',
        'reason',
    ];
}
///////End-of-File : AccountLock.php

File : ApprovalHierarchy.php
/////////Content of file ApprovalHierarchy.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User;

class ApprovalHierarchy extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = [
        'approver_id',
        'level',
        'topic',
        'combo_json',
        'powers_json',
        'is_active'
    ];

    protected $casts = [
        'combo_json' => 'array',
        'powers_json' => 'array',
        'level' => 'integer',
        'is_active' => 'boolean',
    ];

    public function approver()
    {
        return $this->belongsTo(User::class, 'approver_id');
    }

    // Link to graph node
    public function graphNode()
    {
        return $this->morphOne(GraphNode::class, 'nodeable');
    }

    // Initiate approval
    public function initiate(array $data): bool
    {
        // Validate combo/powers
        if (!$this->matchesCombo($data['combo'])) {
            return false;
        }
        // Create graph path
        $this->buildGraphPath();
        // Notify approver
        return true;
    }

    // Check combo match
    protected function matchesCombo(array $queryCombo): bool
    {
        $combo = $this->combo_json ?? [];
        foreach ($queryCombo as $key => $value) {
            if (($combo[$key] ?? null) !== $value && ($combo[$key] ?? null) !== null) {
                return false;
            }
        }
        return true;
    }

    // Build graph for levels
    protected function buildGraphPath()
    {
        $start = GraphNode::create(['user_id' => auth()->id(), 'role' => 'initiator', 'attributes' => ['topic' => $this->topic, 'combo_json' => $this->combo_json]]);
        $current = $start;
        for ($i = 1; $i <= $this->level; $i++) {
            $next = GraphNode::create(['user_id' => $this->approver_id, 'role' => "level_$i", 'attributes' => $this->powers_json]);
            GraphEdge::create(['from_node_id' => $current->id, 'to_node_id' => $next->id, 'type' => 'approval', 'level' => $i, 'powers' => $this->powers_json]);
            $current = $next;
        }
    }
}
///////End-of-File : ApprovalHierarchy.php

File : Branch.php
/////////Content of file Branch.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

use OpenApi\Attributes as OA;

#[OA\Schema(title: 'Branch')]
/**
 * Branch Model
 * 
 * Represents company branches/offices
 */
class Branch extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'branches';
    public $scopeType = 'branch';

    protected $fillable = [
        'code',
        'name',
        'short_name',
        'description',
        'phone',
        'email',
        'address',
        'city',
        'state',
        'pincode',
        'country',
        'latitude',
        'longitude',
        'is_head_office',
        'is_active',
    ];

    protected $casts = [
        'is_head_office' => 'boolean',
        'is_active' => 'boolean',
        'latitude' => 'float',
        'longitude' => 'float',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Locations under this branch
     */
    public function locations()
    {
        return $this->hasMany(Location::class);
    }

    /**
     * Relationship: Employees assigned to branch
     */
    public function employees()
    {
        return $this->belongsToMany(
            Employee::class,
            'employee_branch_assignments',
            'branch_id',
            'employee_id'
        )->withPivot(['from_date', 'to_date', 'is_primary', 'is_current']);
    }

    /**
     * Relationship: Departments
     */
    public function departments()
    {
        return $this->hasMany(Department::class);
    }

    /**
     * Scope: Only head office
     */
    public function scopeHeadOffice($query)
    {
        return $query->where('is_head_office', true);
    }

    /**
     * Scope: Get branches by city
     */
    public function scopeByCity($query, $city)
    {
        return $query->where('city', $city);
    }

    /**
     * Scope: Get branches by state
     */
    public function scopeByState($query, $state)
    {
        return $query->where('state', $state);
    }

    /**
     * Generate auto code
     */
    public static function generateCode($prefix = 'BR')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $prefix . '-' . str_pad($lastId + 1, 3, '0', STR_PAD_LEFT);
    }

    /**
     * Get full address
     */
    public function getFullAddressAttribute()
    {
        return "{$this->address}, {$this->city}, {$this->state} {$this->pincode}";
    }
}
///////End-of-File : Branch.php

File : Brand.php
/////////Content of file Brand.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Brand extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['name', 'code', 'description', 'is_active'];
    protected string $scopeType = 'brand';
    //public $translatable = ['name', 'description'];

    protected $columnTransformations = [
        'code' => 'uppercase_alphanumeric_dash',
    ];

    public function segments()
    {
        return $this->hasMany(Segment::class);
    }
}
///////End-of-File : Brand.php

File : Color.php
/////////Content of file Color.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Color extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['brand_id', 'segment_id', 'sub_segment_id', 'vehicle_model_id', 'name', 'code', 'hex_code', 'image', 'description', 'is_active'];
    protected string $scopeType = 'color';
    //public $translatable = ['name', 'description'];

    protected $columnTransformations = [
        'code' => 'uppercase_alphanumeric_dash',
    ];

    public function brand()
    {
        return $this->belongsTo(Brand::class);
    }

    public function segment()
    {
        return $this->belongsTo(Segment::class);
    }

    public function subSegment()
    {
        return $this->belongsTo(SubSegment::class);
    }

    public function vehicleModel()
    {
        return $this->belongsTo(VehicleModel::class);
    }

    public function variants()
    {
        return $this->belongsToMany(Variant::class, 'variant_colors');
    }
}
///////End-of-File : Color.php

File : d
/////////Content of file d
///////End-of-File : d

File : Department.php
/////////Content of file Department.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use OpenApi\Attributes as OA;

#[OA\Schema(title: 'Department')]
/**
 * Department Model
 * 
 * Represents organizational departments (Sales, HR, Finance, etc.)
 */
class Department extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'departments';
    protected string $scopeType = 'department';
    protected $fillable = [
        'code',
        'name',
        'description',
        'parent_department_id',
        'branch_id',
        'head_id',
        'is_active',
    ];

    protected $casts = [
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Parent department (hierarchical)
     */
    public function parent()
    {
        return $this->belongsTo(self::class, 'parent_department_id');
    }

    /**
     * Relationship: Child departments
     */
    public function children()
    {
        return $this->hasMany(self::class, 'parent_department_id');
    }

    /**
     * Relationship: Department head (Person)
     */
    public function head()
    {
        return $this->belongsTo(Person::class, 'head_id');
    }

    /**
     * Relationship: Branch
     */
    public function branch()
    {
        return $this->belongsTo(Branch::class);
    }

    /**
     * Relationship: Posts under department
     */
    public function posts()
    {
        return $this->hasMany(Post::class);
    }

    /**
     * Relationship: Divisions
     */
    public function divisions()
    {
        return $this->hasMany(Division::class);
    }

    /**
     * Relationship: Employees
     */
    public function employees()
    {
        return $this->belongsToMany(
            Employee::class,
            'employee_department_assignments',
            'department_id',
            'employee_id'
        )->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Scope: Get top-level departments
     */
    public function scopeTopLevel($query)
    {
        return $query->whereNull('parent_department_id');
    }

    /**
     * Scope: Get departments in specific branch
     */
    public function scopeInBranch($query, $branchId)
    {
        return $query->where('branch_id', $branchId);
    }

    /**
     * Get all descendants (flat list)
     */
    public function getAllDescendants()
    {
        $descendants = collect();
        foreach ($this->children as $child) {
            $descendants->push($child);
            $descendants = $descendants->merge($child->getAllDescendants());
        }
        return $descendants;
    }

    /**
     * Generate auto code
     */
    public static function generateCode($prefix = 'DEPT')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $prefix . '-' . str_pad($lastId + 1, 3, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : Department.php

File : Designation.php
/////////Content of file Designation.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Designation extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'designations';
    protected string $scopeType = 'designation';
    protected $fillable = [
        'code',
        'name',
        'description',
        'hierarchy_level',
        'is_active',
    ];

    protected $casts = [
        'hierarchy_level' => 'integer',
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Employees
     */
    public function employees()
    {
        return $this->hasMany(Employee::class);
    }

    /**
     * Relationship: Posts
     */
    public function posts()
    {
        return $this->hasMany(Post::class);
    }

    /**
     * Generate auto code
     */
    public static function generateCode($prefix = 'DES')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $prefix . '-' . str_pad($lastId + 1, 3, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : Designation.php

File : DeviceSession.php
/////////Content of file DeviceSession.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;

class DeviceSession extends BaseModel
{
    protected $fillable = [
        'user_id',
        'device_id',
        'device_name',
        'platform',
        'last_active_at',
    ];
}
///////End-of-File : DeviceSession.php

File : Division.php
/////////Content of file Division.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Division extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'divisions';

    protected $fillable = [
        'department_id',
        'code',
        'name',
        'description',
        'head_id',
        'is_active',
    ];

    protected $casts = [
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Department
     */
    public function department()
    {
        return $this->belongsTo(Department::class);
    }

    /**
     * Relationship: Head (Person)
     */
    public function head()
    {
        return $this->belongsTo(Person::class, 'head_id');
    }

    /**
     * Generate auto code
     */
    public static function generateCode($deptCode, $prefix = 'DIV')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $deptCode . '-' . $prefix . '-' . str_pad($lastId + 1, 3, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : Division.php

File : Employee.php
/////////Content of file Employee.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Employee extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'employees';

    protected $fillable = [
        'code',
        'person_id',
        'designation_id',
        'primary_branch_id',
        'primary_department_id',
        'joining_date',
        'resignation_date',
        'employment_type',
        'employment_status',
        'is_active',
    ];

    protected $casts = [
        'joining_date' => 'date',
        'resignation_date' => 'date',
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Person
     */
    public function person()
    {
        return $this->belongsTo(Person::class);
    }

    /**
     * Relationship: Designation
     */
    public function designation()
    {
        return $this->belongsTo(Designation::class);
    }

    /**
     * Relationship: Primary Branch
     */
    public function primaryBranch()
    {
        return $this->belongsTo(Branch::class, 'primary_branch_id');
    }

    /**
     * Relationship: Primary Department
     */
    public function primaryDepartment()
    {
        return $this->belongsTo(Department::class, 'primary_department_id');
    }

    /**
     * Relationship: Branches
     */
    public function branches()
    {
        return $this->belongsToMany(Branch::class, 'employee_branch_assignments')
            ->withPivot(['from_date', 'to_date', 'is_primary', 'is_current']);
    }

    /**
     * Relationship: Departments
     */
    public function departments()
    {
        return $this->belongsToMany(Department::class, 'employee_department_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Relationship: Locations
     */
    public function locations()
    {
        return $this->belongsToMany(Location::class, 'employee_location_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Relationship: Verticals
     */
    public function verticals()
    {
        return $this->belongsToMany(Vertical::class, 'employee_vertical_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Relationship: Posts
     */
    public function posts()
    {
        return $this->belongsToMany(Post::class, 'employee_post_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current', 'assignment_order']);
    }

    /**
     * Get current scope (for RBAC filtering)
     */
    public function getCurrentScope()
    {
        return [
            'branches' => $this->branches()->wherePivot('is_current', true)->pluck('branches.id')->toArray(),
            'departments' => $this->departments()->wherePivot('is_current', true)->pluck('departments.id')->toArray(),
            'locations' => $this->locations()->wherePivot('is_current', true)->pluck('locations.id')->toArray(),
            'verticals' => $this->verticals()->wherePivot('is_current', true)->pluck('verticals.id')->toArray(),
        ];
    }

    /**
     * Generate auto code
     */
    public static function generateCode($prefix = 'EMP')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $prefix . '-' . str_pad($lastId + 1, 6, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : Employee.php

File : EmployeeBranchAssignment.php
/////////Content of file EmployeeBranchAssignment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class EmployeeBranchAssignment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'employee_branch_assignments';

    protected $fillable = [
        'employee_id',
        'branch_id',
        'from_date',
        'to_date',
        'is_primary',
        'is_current',
    ];

    protected $casts = [
        'from_date' => 'date',
        'to_date' => 'date',
        'is_primary' => 'boolean',
        'is_current' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Employee
     */
    public function employee()
    {
        return $this->belongsTo(Employee::class);
    }

    /**
     * Relationship: Branch
     */
    public function branch()
    {
        return $this->belongsTo(Branch::class);
    }
}
///////End-of-File : EmployeeBranchAssignment.php

File : EmployeeDepartmentAssignment.php
/////////Content of file EmployeeDepartmentAssignment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class EmployeeDepartmentAssignment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'employee_department_assignments';

    protected $fillable = [
        'employee_id',
        'department_id',
        'from_date',
        'to_date',
        'is_current',
    ];

    protected $casts = [
        'from_date' => 'date',
        'to_date' => 'date',
        'is_current' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Employee
     */
    public function employee()
    {
        return $this->belongsTo(Employee::class);
    }

    /**
     * Relationship: Department
     */
    public function department()
    {
        return $this->belongsTo(Department::class);
    }
}
///////End-of-File : EmployeeDepartmentAssignment.php

File : EmployeeLocationAssignment.php
/////////Content of file EmployeeLocationAssignment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class EmployeeLocationAssignment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'employee_location_assignments';

    protected $fillable = [
        'employee_id',
        'location_id',
        'branch_id',
        'from_date',
        'to_date',
        'is_current',
    ];

    protected $casts = [
        'from_date' => 'date',
        'to_date' => 'date',
        'is_current' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Employee
     */
    public function employee()
    {
        return $this->belongsTo(Employee::class);
    }

    /**
     * Relationship: Location
     */
    public function location()
    {
        return $this->belongsTo(Location::class);
    }

    /**
     * Relationship: Branch
     */
    public function branch()
    {
        return $this->belongsTo(Branch::class);
    }
}
///////End-of-File : EmployeeLocationAssignment.php

File : EmployeePostAssignment.php
/////////Content of file EmployeePostAssignment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class EmployeePostAssignment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'employee_post_assignments';

    protected $fillable = [
        'employee_id',
        'post_id',
        'from_date',
        'to_date',
        'assignment_order',
        'is_current',
        'remarks',
    ];

    protected $casts = [
        'from_date' => 'date',
        'to_date' => 'date',
        'is_current' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Employee
     */
    public function employee()
    {
        return $this->belongsTo(Employee::class);
    }

    /**
     * Relationship: Post
     */
    public function post()
    {
        return $this->belongsTo(Post::class);
    }
}
///////End-of-File : EmployeePostAssignment.php

File : EmployeeVerticalAssignment.php
/////////Content of file EmployeeVerticalAssignment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class EmployeeVerticalAssignment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'employee_vertical_assignments';

    protected $fillable = [
        'employee_id',
        'vertical_id',
        'from_date',
        'to_date',
        'is_current',
    ];

    protected $casts = [
        'from_date' => 'date',
        'to_date' => 'date',
        'is_current' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Employee
     */
    public function employee()
    {
        return $this->belongsTo(Employee::class);
    }

    /**
     * Relationship: Vertical
     */
    public function vertical()
    {
        return $this->belongsTo(Vertical::class);
    }
}
///////End-of-File : EmployeeVerticalAssignment.php

File : ExportLog.php
/////////Content of file ExportLog.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class ExportLog extends Model
{
    use SoftDeletes;

    protected $table = 'export_logs';

    protected $fillable = [
        'user_id',
        'filename',
        'export_type',
        'total_records',
        'filters',
        'file_path',
        'file_size',
        'status',
        'duration_seconds',
        'started_at',
        'completed_at',
        'downloaded_at',
        'download_count',
    ];

    protected $casts = [
        'filters' => 'array',
        'started_at' => 'datetime',
        'completed_at' => 'datetime',
        'downloaded_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship with User
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Scope: Get successful exports
     */
    public function scopeSuccessful($query)
    {
        return $query->where('status', 'success');
    }

    /**
     * Scope: Get failed exports
     */
    public function scopeFailed($query)
    {
        return $query->where('status', 'failed');
    }

    /**
     * Scope: Get downloaded exports
     */
    public function scopeDownloaded($query)
    {
        return $query->whereNotNull('downloaded_at');
    }

    /**
     * Get export type label
     */
    public function getExportTypeLabel()
    {
        return match ($this->export_type) {
            'standard_users' => 'Standard Users',
            'rules_users' => 'Rules Users',
            'vehicle_inventory' => 'Vehicle Inventory',
            default => $this->export_type,
        };
    }

    /**
     * Get status badge class
     */
    public function getStatusBadgeClass()
    {
        return match ($this->status) {
            'success' => 'badge-success',
            'failed' => 'badge-danger',
            default => 'badge-secondary',
        };
    }

    /**
     * Mark as downloaded
     */
    public function markAsDownloaded()
    {
        $this->update([
            'downloaded_at' => now(),
            'download_count' => $this->download_count + 1,
        ]);
    }

    /**
     * Format file size for display
     */
    public function getFormattedFileSize()
    {
        if (!$this->file_size) return '0 B';

        $units = ['B', 'KB', 'MB', 'GB'];
        $size = $this->file_size;

        foreach ($units as $unit) {
            if ($size < 1024) {
                return round($size, 2) . ' ' . $unit;
            }
            $size /= 1024;
        }

        return round($size, 2) . ' TB';
    }
}
///////End-of-File : ExportLog.php

File : Garage.php
/////////Content of file Garage.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Garage extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'garages';

    protected $fillable = [
        'person_id',
        'name',
        'type',
        'address',
        'city',
        'state',
        'pincode',
        'latitude',
        'longitude',
        'contact_person',
        'mobile',
        'is_active',
    ];

    protected $casts = [
        'latitude' => 'float',
        'longitude' => 'float',
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Person
     */
    public function person()
    {
        return $this->belongsTo(Person::class);
    }
}
///////End-of-File : Garage.php

File : GraphEdge.php
/////////Content of file GraphEdge.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class GraphEdge extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['from_node_id', 'to_node_id', 'type', 'level', 'powers'];

    protected $casts = ['powers' => 'array'];

    public function fromNode()
    {
        return $this->belongsTo(GraphNode::class, 'from_node_id');
    }

    public function toNode()
    {
        return $this->belongsTo(GraphNode::class, 'to_node_id');
    }

    // Match topic/combo
    public function matches(string $topic, array $queryCombo): bool
    {
        if ($this->powers['topic'] ?? '' !== $topic) return false;
        $edgeCombo = $this->powers['combo_json'] ?? [];
        foreach ($queryCombo as $k => $v) {
            if (($edgeCombo[$k] ?? null) !== $v && ($edgeCombo[$k] ?? null) !== null) return false;
        }
        return true;
    }
}
///////End-of-File : GraphEdge.php

File : GraphNode.php
/////////Content of file GraphNode.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User;

class GraphNode extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['user_id', 'role', 'attributes'];

    protected $casts = ['attributes' => 'array'];

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function outgoingEdges()
    {
        return $this->hasMany(GraphEdge::class, 'from_node_id');
    }

    public function incomingEdges()
    {
        return $this->hasMany(GraphEdge::class, 'to_node_id');
    }

    // Polymorphic for ApprovalHierarchy
    public function nodeable()
    {
        return $this->morphTo();
    }

    // Get subtree for topic/combo
    public function getSubtree(string $topic, array $combo): array
    {
        $subtree = [$this];
        foreach ($this->outgoingEdges as $edge) {
            if ($edge->matches($topic, $combo)) {
                $subtree = array_merge($subtree, $edge->toNode->getSubtree($topic, $combo));
            }
        }
        return $subtree;
    }

    // Get subtree user IDs
    public function getSubtreeUserIds(string $topic, array $combo): array
    {
        return collect($this->getSubtree($topic, $combo))->pluck('user_id')->unique()->toArray();
    }
}
///////End-of-File : GraphNode.php

File : ImportLog.php
/////////Content of file ImportLog.php
<?php

namespace App\Models\Core;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class ImportLog extends Model
{
    use SoftDeletes;

    protected $table = 'import_logs';

    protected $fillable = [
        'user_id',
        'filename',
        'import_type',
        'total_records',
        'imported_count',
        'skipped_count',
        'errors_count',
        'errors',
        'warnings',
        'status',
        'duration_seconds',
        'started_at',
        'completed_at',
    ];

    protected $casts = [
        'errors' => 'array',
        'warnings' => 'array',
        'started_at' => 'datetime',
        'completed_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship with User
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Scope: Get successful imports
     */
    public function scopeSuccessful($query)
    {
        return $query->where('status', 'success');
    }

    /**
     * Scope: Get failed imports
     */
    public function scopeFailed($query)
    {
        return $query->where('status', 'failed');
    }

    /**
     * Scope: Get partial imports
     */
    public function scopePartial($query)
    {
        return $query->where('status', 'partial');
    }

    /**
     * Get import type label
     */
    public function getImportTypeLabel()
    {
        return match ($this->import_type) {
            'standard_users' => 'Standard Users',
            'rules_users' => 'Rules Users',
            'vehicle_definition' => 'Vehicle Definition',
            default => $this->import_type,
        };
    }

    /**
     * Get status badge class
     */
    public function getStatusBadgeClass()
    {
        return match ($this->status) {
            'success' => 'badge-success',
            'partial' => 'badge-warning',
            'failed' => 'badge-danger',
            default => 'badge-secondary',
        };
    }
}
///////End-of-File : ImportLog.php

File : Keyvalue.php
/////////Content of file Keyvalue.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\Traits\HasTreeStructure;

class Keyvalue extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    use HasTreeStructure;
    protected $fillable = [
        'keyword_master_id',
        'key',
        'value',
        'details',
        'parent_id',
        'level',
        'extra_data',
        'status'
    ];

    protected $casts = [
        'extra_data' => 'array',
        'level' => 'integer',
        'status' => 'integer',
    ];

    public function keywordMaster()
    {
        return $this->belongsTo(KeywordMaster::class);
    }

    public function parent()
    {
        return $this->belongsTo(self::class, 'parent_id');
    }

    public function children()
    {
        return $this->hasMany(self::class, 'parent_id');
    }

    public function registerMediaCollections(): void
    {
        parent::registerMediaCollections();
        $this->addMediaCollection('attachments')
            ->singleFile() // Or multiple if needed
            ->useDisk('public');
    }

    public static function getEnum(string $keyword, bool $activeOnly = true, bool $recursive = false): array
    {
        $master = KeywordMaster::where('keyword', $keyword)->first();
        if (!$master) return [];

        $query = self::where('keyword_master_id', $master->id);
        if ($activeOnly) $query->where('status', 1);

        if ($recursive) {
            return $query->with('children')->whereNull('parent_id')->get()->toArray();
        }
        return $query->pluck('value', 'key')->toArray();
    }

    public static function getKeywordId(string $keyword): ?int
    {
        return KeywordMaster::where('keyword', $keyword)->value('id');
    }

    public static function getValueId(string $keyword, string $valKey): ?int
    {
        $masterId = self::getKeywordId($keyword);
        return self::where('keyword_master_id', $masterId)->where('key', $valKey)->value('id');
    }

    public function scopeForKeyword($query, string $keyword)
    {
        $masterId = self::getKeywordId($keyword);
        return $query->where('keyword_master_id', $masterId);
    }

    public function scopeRoots($query)
    {
        return $query->whereNull('parent_id');
    }
}
///////End-of-File : Keyvalue.php

File : KeywordMaster.php
/////////Content of file KeywordMaster.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class KeywordMaster extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['keyword', 'details', 'extra_data', 'status'];

    protected $casts = [
        'extra_data' => 'array',
        'status' => 'integer',
    ];

    public function keyvalues()
    {
        return $this->hasMany(Keyvalue::class);
    }

    public function scopeByKeyword($query, string $keyword)
    {
        return $query->where('keyword', $keyword);
    }

    // DO NOT use HasTreeStructure here!
}
///////End-of-File : KeywordMaster.php

File : Location.php
/////////Content of file Location.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Location extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'locations';
    public $scopeType = 'location';
    protected $fillable = [
        'branch_id',
        'code',
        'name',
        'description',
        'phone',
        'email',
        'address',
        'city',
        'state',
        'pincode',
        'latitude',
        'longitude',
        'is_active',
    ];

    protected $casts = [
        'latitude' => 'float',
        'longitude' => 'float',
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Branch
     */
    public function branch()
    {
        return $this->belongsTo(Branch::class);
    }

    /**
     * Relationship: Employees
     */
    public function employees()
    {
        return $this->belongsToMany(Employee::class, 'employee_location_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Generate auto code
     */
    public static function generateCode($branchCode, $prefix = 'LOC')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $branchCode . '-' . $prefix . '-' . str_pad($lastId + 1, 3, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : Location.php

File : Module.php
/////////Content of file Module.php
<?php

namespace App\Models\Core;

use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\BaseModel;

class Module extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['name', 'code', 'description', 'is_active'];

    public function processes()
    {
        return $this->hasMany(Process::class);
    }
}
///////End-of-File : Module.php

File : OtpAttemptLog.php
/////////Content of file OtpAttemptLog.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;

class OtpAttemptLog extends BaseModel
{
    protected $fillable = [
        'user_id',
        'mobile',
        'action',
        'ip_address',
        'user_agent',
        'reason',
    ];
}
///////End-of-File : OtpAttemptLog.php

File : OtpToken.php
/////////Content of file OtpToken.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;

class OtpToken extends BaseModel
{
    protected $fillable = [
        'user_id',
        'otp_hash',
        'mobile',
        'expires_at',
    ];
}
///////End-of-File : OtpToken.php

File : Permission.php
/////////Content of file Permission.php
<?php

namespace App\Models\Core;

use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

use Spatie\Permission\Models\Permission as SpatiePermission;

class Permission extends SpatiePermission
{
    use CrudTrait;
    use HasFactory;
    // Add relations
    public function module()
    {
        return $this->belongsTo(Module::class);
    }

    public function process()
    {
        return $this->belongsTo(Process::class);
    }
}
///////End-of-File : Permission.php

File : Person.php
/////////Content of file Person.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User; 

class Person extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'persons';

    protected $fillable = [
        'code',
        'salutation',
        'first_name',
        'middle_name',
        'last_name',
        'display_name',
        'gender',
        'dob',
        'marital_status',
        'spouse_name',
        'occupation',
        'aadhaar_no',
        'pan_no',
        'gst_no',
        'mobile_primary',
        'mobile_secondary',
        'email_primary',
        'email_secondary',
        'extra_data',
    ];

    protected $casts = [
        'dob' => 'date',
        'extra_data' => 'array',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Addresses
     */
    public function addresses()
    {
        return $this->hasMany(PersonAddress::class);
    }

    /**
     * Relationship: Contacts
     */
    public function contacts()
    {
        return $this->hasMany(PersonContact::class);
    }

    /**
     * Relationship: Banking details
     */
    public function bankingDetails()
    {
        return $this->hasMany(PersonBankingDetail::class);
    }

    /**
     * Relationship: Garages
     */
    public function garages()
    {
        return $this->hasMany(Garage::class);
    }

    /**
     * Relationship: Employee record (if person is employee)
     */
    public function employee()
    {
        return $this->hasOne(Employee::class);
    }

    /**
     * Relationship: User record (if person has login)
     */
    public function user()
    {
        return $this->hasOne(User::class);
    }

    /**
     * Relationship: Department heads
     */
    public function headedDepartments()
    {
        return $this->hasMany(Department::class, 'head_id');
    }

    /**
     * Relationship: Division heads
     */
    public function headedDivisions()
    {
        return $this->hasMany(Division::class, 'head_id');
    }

    /**
     * Scope: Search persons
     */
    public function scopeSearch($query, $term)
    {
        return $query->where('first_name', 'like', "%{$term}%")
            ->orWhere('last_name', 'like', "%{$term}%")
            ->orWhere('display_name', 'like', "%{$term}%")
            ->orWhere('email_primary', 'like', "%{$term}%")
            ->orWhere('mobile_primary', 'like', "%{$term}%");
    }

    /**
     * Get full name
     */
    public function getFullNameAttribute()
    {
        return trim("{$this->first_name} {$this->middle_name} {$this->last_name}");
    }

    /**
     * Get primary contact
     */
    public function getPrimaryContactAttribute()
    {
        return $this->contacts()
            ->where('is_primary', true)
            ->first() ?? $this->contacts()->first();
    }

    /**
     * Generate auto code
     */
    public static function generateCode()
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return 'PERS-' . str_pad($lastId + 1, 6, '0', STR_PAD_LEFT);
    }

    /**
     * Register media collections
     */
    public function registerMediaCollections(): void
    {
        parent::registerMediaCollections();

        $this->addMediaCollection('identity_documents')
            ->acceptsMimeTypes(['application/pdf', 'image/jpeg', 'image/png'])
            ->useDisk('public');

        $this->addMediaCollection('profile_photos')
            ->acceptsMimeTypes(['image/jpeg', 'image/png'])
            ->useDisk('public');
    }
}
///////End-of-File : Person.php

File : PersonAddress.php
/////////Content of file PersonAddress.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

/**
 * PersonAddress Model
 * 
 * Multiple addresses for a person (Residential, Office, Billing, etc.)
 */
class PersonAddress extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'person_addresses';

    protected $fillable = [
        'person_id',
        'type',
        'address_line_1',
        'address_line_2',
        'city',
        'state',
        'pincode',
        'country',
        'latitude',
        'longitude',
        'is_primary',
        'notes',
    ];

    protected $casts = [
        'is_primary' => 'boolean',
        'latitude' => 'float',
        'longitude' => 'float',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Person
     */
    public function person()
    {
        return $this->belongsTo(Person::class);
    }

    /**
     * Scope: Get by type
     */
    public function scopeByType($query, $type)
    {
        return $query->where('type', $type);
    }

    /**
     * Scope: Get primary address
     */
    public function scopePrimary($query)
    {
        return $query->where('is_primary', true)->first();
    }

    /**
     * Get full address string
     */
    public function getFullAddressAttribute()
    {
        $address = $this->address_line_1;
        if ($this->address_line_2) {
            $address .= ", {$this->address_line_2}";
        }
        $address .= ", {$this->city}, {$this->state} {$this->pincode}";
        return $address;
    }
}
///////End-of-File : PersonAddress.php

File : PersonBankingDetail.php
/////////Content of file PersonBankingDetail.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

/**
 * PersonBankingDetail Model
 * 
 * Bank account information for persons
 */
class PersonBankingDetail extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'person_banking_details';

    protected $fillable = [
        'person_id',
        'bank_name',
        'account_holder_name',
        'account_number',
        'ifsc_code',
        'account_type',
        'branch_name',
        'swift_code',
        'is_primary',
        'is_verified',
        'verified_at',
    ];

    protected $casts = [
        'is_primary' => 'boolean',
        'is_verified' => 'boolean',
        'verified_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Person
     */
    public function person()
    {
        return $this->belongsTo(Person::class);
    }

    /**
     * Scope: Only verified accounts
     */
    public function scopeVerified($query)
    {
        return $query->where('is_verified', true);
    }

    /**
     * Scope: Get primary bank
     */
    public function scopePrimary($query)
    {
        return $query->where('is_primary', true)->first();
    }

    /**
     * Get masked account number
     */
    public function getMaskedAccountAttribute()
    {
        $number = $this->account_number;
        return substr_replace($number, '****', 2, -4);
    }
}
///////End-of-File : PersonBankingDetail.php

File : PersonContact.php
/////////Content of file PersonContact.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

/**
 * PersonContact Model
 * 
 * Emergency and reference contacts for a person
 */
class PersonContact extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'person_contacts';

    protected $fillable = [
        'person_id',
        'type',
        'name',
        'mobile',
        'email',
        'relationship',
        'notes',
        'is_primary',
    ];

    protected $casts = [
        'is_primary' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Person
     */
    public function person()
    {
        return $this->belongsTo(Person::class);
    }

    /**
     * Scope: Get by type
     */
    public function scopeByType($query, $type)
    {
        return $query->where('type', $type);
    }

    /**
     * Scope: Emergency contacts
     */
    public function scopeEmergency($query)
    {
        return $query->where('type', 'emergency');
    }
}
///////End-of-File : PersonContact.php

File : Post.php
/////////Content of file Post.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Employee extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'employees';

    protected $fillable = [
        'code',
        'person_id',
        'designation_id',
        'primary_branch_id',
        'primary_department_id',
        'joining_date',
        'resignation_date',
        'employment_type',
        'employment_status',
        'is_active',
    ];

    protected $casts = [
        'joining_date' => 'date',
        'resignation_date' => 'date',
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Person
     */
    public function person()
    {
        return $this->belongsTo(Person::class);
    }

    /**
     * Relationship: Designation
     */
    public function designation()
    {
        return $this->belongsTo(Designation::class);
    }

    /**
     * Relationship: Primary Branch
     */
    public function primaryBranch()
    {
        return $this->belongsTo(Branch::class, 'primary_branch_id');
    }

    /**
     * Relationship: Primary Department
     */
    public function primaryDepartment()
    {
        return $this->belongsTo(Department::class, 'primary_department_id');
    }

    /**
     * Relationship: Branches
     */
    public function branches()
    {
        return $this->belongsToMany(Branch::class, 'employee_branch_assignments')
            ->withPivot(['from_date', 'to_date', 'is_primary', 'is_current']);
    }

    /**
     * Relationship: Departments
     */
    public function departments()
    {
        return $this->belongsToMany(Department::class, 'employee_department_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Relationship: Locations
     */
    public function locations()
    {
        return $this->belongsToMany(Location::class, 'employee_location_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Relationship: Verticals
     */
    public function verticals()
    {
        return $this->belongsToMany(Vertical::class, 'employee_vertical_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Relationship: Posts
     */
    public function posts()
    {
        return $this->belongsToMany(Post::class, 'employee_post_assignments')
            ->withPivot(['from_date', 'to_date', 'is_current', 'assignment_order']);
    }

    /**
     * Get current scope (for RBAC filtering)
     */
    public function getCurrentScope()
    {
        return [
            'branches' => $this->branches()->wherePivot('is_current', true)->pluck('branches.id')->toArray(),
            'departments' => $this->departments()->wherePivot('is_current', true)->pluck('departments.id')->toArray(),
            'locations' => $this->locations()->wherePivot('is_current', true)->pluck('locations.id')->toArray(),
            'verticals' => $this->verticals()->wherePivot('is_current', true)->pluck('verticals.id')->toArray(),
        ];
    }

    /**
     * Generate auto code
     */
    public static function generateCode($prefix = 'EMP')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $prefix . '-' . str_pad($lastId + 1, 6, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : Post.php

File : PostPermission.php
/////////Content of file PostPermission.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User; 

/**
 * PostPermission Model
 * 
 * Links permissions to posts for RBAC
 */
class PostPermission extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'post_permissions';

    protected $fillable = [
        'post_id',
        'permission_id',
        'granted_by',
        'granted_at',
    ];

    protected $casts = [
        'granted_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * Relationship: Post
     */
    public function post()
    {
        return $this->belongsTo(Post::class);
    }

    /**
     * Relationship: Permission
     */
    public function permission()
    {
        return $this->belongsTo(\Spatie\Permission\Models\Permission::class);
    }

    /**
     * Relationship: User who granted
     */
    public function grantedBy()
    {
        return $this->belongsTo(User::class, 'granted_by');
    }
}
///////End-of-File : PostPermission.php

File : Process.php
/////////Content of file Process.php
<?php

namespace App\Models\Core;

use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Process extends Model
{
    use CrudTrait;
    use HasFactory;

    protected $fillable = ['module_id', 'name', 'code', 'description', 'is_active'];

    public function module()
    {
        return $this->belongsTo(Module::class);
    }
}
///////End-of-File : Process.php

File : ReportingHierarchy.php
/////////Content of file ReportingHierarchy.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User;
use Kalnoy\Nestedset\NodeTrait; // Install baum/baum for NestedSet

class ReportingHierarchy extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    use NodeTrait;

    protected $fillable = [
        'user_id',
        'supervisor_id',
        'topic',
        'combo_json',
        'is_active'
    ];

    protected $casts = [
        'combo_json' => 'array',
        'is_active' => 'boolean',
    ];

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function supervisor()
    {
        return $this->belongsTo(User::class, 'supervisor_id');
    }

    // Get subtree user IDs for topic/combo
    public function getSubtreeUserIds(string $topic, array $combo): array
    {
        return $this->descendantsAndSelf()
            ->where('topic', $topic)
            ->whereJsonContains('combo_json', $combo)
            ->pluck('user_id')
            ->unique()
            ->toArray();
    }
}
///////End-of-File : ReportingHierarchy.php

File : Role.php
/////////Content of file Role.php
<?php

namespace App\Models\Core;

use Spatie\Permission\Models\Role as SpatieRole;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

class Role extends SpatieRole
{
    use CrudTrait;

    protected $table = 'roles';
    protected $guarded = [];

    // Optional: Add any custom methods here

    /**
     * Get users with this role
     */
    public function users(): BelongsToMany
    {
        return $this->morphedByMany(
            config('auth.providers.users.model'),
            'model',
            'model_has_roles',
            'role_id',
            'model_id'
        );
    }

    /**
     * Custom scope: Get active roles
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Get permission count
     */
    public function getPermissionsCountAttribute()
    {
        return $this->permissions()->count();
    }
}
///////End-of-File : Role.php

File : Segment.php
/////////Content of file Segment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Segment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['brand_id', 'name', 'code', 'description', 'is_active'];

    public $translatable = ['name', 'description'];

    protected $columnTransformations = [
        'code' => 'uppercase_alphanumeric_dash',
    ];

    public function brand()
    {
        return $this->belongsTo(Brand::class);
    }

    public function subSegments()
    {
        return $this->hasMany(SubSegment::class);
    }

    public function vehicleModels()
    {
        return $this->hasMany(VehicleModel::class);
    }

    public function variants()
    {
        return $this->hasMany(Variant::class);
    }
}
///////End-of-File : Segment.php

File : SubSegment.php
/////////Content of file SubSegment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class SubSegment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['segment_id', 'name', 'code', 'description', 'is_active'];

    public $translatable = ['name', 'description'];

    protected $columnTransformations = [
        'code' => 'uppercase_alphanumeric_dash',
    ];

    public function segment()
    {
        return $this->belongsTo(Segment::class);
    }

    public function brand()
    {
        return $this->belongsTo(Brand::class, 'brand_id');
    }

    public function vehicleModels()
    {
        return $this->hasMany(VehicleModel::class);
    }

    public function variants()
    {
        return $this->hasMany(Variant::class);
    }
}
///////End-of-File : SubSegment.php

File : SystemSetting.php
/////////Content of file SystemSetting.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Support\Facades\Cache;

/**
 * SystemSetting Model
 * 
 * Stores application configuration settings
 * Cached for performance optimization
 */
class SystemSetting extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'system_settings';

    protected $fillable = [
        'key',
        'value',
        'type',
        'description',
        'is_editable',
    ];

    protected $casts = [
        'is_editable' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * Boot: Clear cache when setting is updated
     */
    public static function boot()
    {
        parent::boot();

        static::saved(function ($model) {
            Cache::forget("setting.{$model->key}");
        });

        static::deleted(function ($model) {
            Cache::forget("setting.{$model->key}");
        });
    }

    /**
     * Get setting value with type casting
     */
    public static function getValue($key, $default = null)
    {
        $setting = Cache::rememberForever("setting.{$key}", function () use ($key) {
            return self::where('key', $key)->first();
        });

        if (!$setting) {
            return $default;
        }

        return match ($setting->type) {
            'boolean' => filter_var($setting->value, FILTER_VALIDATE_BOOLEAN),
            'integer' => (int) $setting->value,
            'float' => (float) $setting->value,
            'array' => json_decode($setting->value, true) ?? [],
            'json' => json_decode($setting->value, true) ?? [],
            default => $setting->value,
        };
    }

    /**
     * Scope: Get only editable settings
     */
    public function scopeEditable($query)
    {
        return $query->where('is_editable', true);
    }

    /**
     * Scope: Get settings by type
     */
    public function scopeByType($query, $type)
    {
        return $query->where('type', $type);
    }
}
///////End-of-File : SystemSetting.php

File : UserDivisionAssignment.php
/////////Content of file UserDivisionAssignment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User; 

/**
 * UserDivisionAssignment Model
 * 
 * Links users to divisions for access control
 */
class UserDivisionAssignment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'user_division_assignments';

    protected $fillable = [
        'user_id',
        'division_id',
        'from_date',
        'to_date',
        'is_current',
    ];

    protected $casts = [
        'from_date' => 'date',
        'to_date' => 'date',
        'is_current' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: User
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Relationship: Division
     */
    public function division()
    {
        return $this->belongsTo(Division::class);
    }

    /**
     * Scope: Current assignments
     */
    public function scopeCurrent($query)
    {
        return $query->where('is_current', true);
    }
}
///////End-of-File : UserDivisionAssignment.php

File : UserRoleAssignment.php
/////////Content of file UserRoleAssignment.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User; 

/**
 * UserRoleAssignment Model
 * 
 * Links users to roles with date validity support
 * Allows users to have multiple roles
 */
class UserRoleAssignment extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'user_role_assignments';

    protected $fillable = [
        'user_id',
        'role_id',
        'from_date',
        'to_date',
        'is_current',
        'remarks',
    ];

    protected $casts = [
        'from_date' => 'date',
        'to_date' => 'date',
        'is_current' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: User
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Relationship: Role
     */
    public function role()
    {
        return $this->belongsTo(\Spatie\Permission\Models\Role::class);
    }

    /**
     * Scope: Current roles
     */
    public function scopeCurrent($query)
    {
        return $query->where('is_current', true)
            ->where(function ($q) {
                $q->whereNull('to_date')
                    ->orWhere('to_date', '>=', now());
            });
    }
}
///////End-of-File : UserRoleAssignment.php

File : UserType.php
/////////Content of file UserType.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Models\User; 

/**
 * UserType Model
 * 
 * Types of users in system (Admin, Employee, Customer, Vendor, etc.)
 */
class UserType extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'user_types';

    protected $fillable = [
        'code',
        'display_name',
        'description',
        'is_active',
    ];

    protected $casts = [
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * Relationship: Users of this type
     */
    public function users()
    {
        return $this->hasMany(User::class);
    }

    /**
     * Generate auto code
     */
    public static function generateCode($prefix = 'UT')
    {
        $lastId = self::max('id') ?? 0;
        return $prefix . '-' . str_pad($lastId + 1, 2, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : UserType.php

File : Variant.php
/////////Content of file Variant.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use App\Helpers\KeywordHelper;

class Variant extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = [
        'brand_id',
        'segment_id',
        'sub_segment_id',
        'vehicle_model_id',
        'name',
        'custom_name',
        'oem_code',
        'description',
        'permit_id',
        'fuel_type_id',
        'seating_capacity',
        'wheels',
        'gvw',
        'cc_capacity',
        'body_type_id',
        'body_make_id',
        'is_csd',
        'csd_index',
        'status_id',
        'is_active'
    ];

    // public $translatable = ['name', 'custom_name', 'description'];

    protected $columnTransformations = [
        'oem_code' => 'uppercase_alphanumeric_dash',
    ];

    public function brand()
    {
        return $this->belongsTo(Brand::class);
    }

    public function segment()
    {
        return $this->belongsTo(Segment::class);
    }

    public function subSegment()
    {
        return $this->belongsTo(SubSegment::class);
    }

    public function vehicleModel()
    {
        return $this->belongsTo(VehicleModel::class);
    }

    public function colors()
    {
        return $this->belongsToMany(Color::class, 'variant_colors');
    }
    public function permit()
    {
        return $this->belongsTo(Keyvalue::class, 'permit_id');
    }

    public function fuelType()
    {
        return $this->belongsTo(Keyvalue::class, 'fuel_type_id');
    }

    public function bodyType()
    {
        return $this->belongsTo(Keyvalue::class, 'body_type_id');
    }

    public function bodyMake()
    {
        return $this->belongsTo(Keyvalue::class, 'body_make_id');
    }

    public function statusKkv()
    {
        return $this->belongsTo(Keyvalue::class, 'status_id');
    }
    // Get options from helper
    public static function getPermitOptions(): array
    {
        return KeywordHelper::options('permit');
    }

    public static function getFuelTypeOptions(): array
    {
        return KeywordHelper::options('fuel_type');
    }

    public static function getBodyTypeOptions(): array
    {
        return KeywordHelper::options('body_type');
    }

    public static function getBodyMakeOptions(): array
    {
        return KeywordHelper::options('body_make');
    }

    public static function getStatusOptions(): array
    {
        return KeywordHelper::options('vehicle_status');
    }
}
///////End-of-File : Variant.php

File : VehicleModel.php
/////////Content of file VehicleModel.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class VehicleModel extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $fillable = ['brand_id', 'segment_id', 'sub_segment_id', 'name', 'custom_name', 'oem_code', 'description', 'is_active'];

    // public $translatable = ['name', 'custom_name', 'description'];

    protected $columnTransformations = [
        'oem_code' => 'uppercase_alphanumeric_dash',
    ];

    public function brand()
    {
        return $this->belongsTo(Brand::class);
    }

    public function segment()
    {
        return $this->belongsTo(Segment::class);
    }

    public function subSegment()
    {
        return $this->belongsTo(SubSegment::class);
    }

    public function variants()
    {
        return $this->hasMany(Variant::class);
    }
}
///////End-of-File : VehicleModel.php

File : Vertical.php
/////////Content of file Vertical.php
<?php

namespace App\Models\Core;

use App\Models\BaseModel;
use Backpack\CRUD\app\Models\Traits\CrudTrait;
use Illuminate\Database\Eloquent\Factories\HasFactory;

/**
 * Vertical Model
 * 
 * Business segments (Personal, Commercial, Fleet, etc.)
 */
class Vertical extends BaseModel
{
    use CrudTrait;
    use HasFactory;
    protected $table = 'verticals';

    protected $fillable = [
        'code',
        'name',
        'description',
        'is_active',
    ];

    protected $casts = [
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    /**
     * Relationship: Employee assignments
     */
    public function employees()
    {
        return $this->belongsToMany(
            Employee::class,
            'employee_vertical_assignments',
            'vertical_id',
            'employee_id'
        )->withPivot(['from_date', 'to_date', 'is_current']);
    }

    /**
     * Generate auto code
     */
    public static function generateCode($prefix = 'VER')
    {
        $lastId = self::withTrashed()->max('id') ?? 0;
        return $prefix . '-' . str_pad($lastId + 1, 2, '0', STR_PAD_LEFT);
    }
}
///////End-of-File : Vertical.php

Folder : d:\xampp\htdocs\vdms\app\.\Models\Scopes

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Models\Scopes

Folder : d:\xampp\htdocs\vdms\app\.\Models\Traits

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Models\Traits

File : d
/////////Content of file d
///////End-of-File : d

File : GraphTraversalTrait.php
/////////Content of file GraphTraversalTrait.php
<?php

namespace App\Models\Traits;

use Graphp\Graph\Graph;
use Graphp\Algorithms\BreadthFirstSearch;
use Illuminate\Support\Facades\Cache;
use App\Models\User;

trait GraphTraversalTrait
{
    public function traverseForUser(User $user, ?string $type = null, ?string $attribute = null): array
    {
        if (!config('app.rbac_graph')) {
            return [];
        }

        $cacheKey = "user_graph_{$user->id}_{$type}_{$attribute}";
        return Cache::remember($cacheKey, 60, function () use ($user, $type, $attribute) {
            $graph = new Graph();
            $nodes = \App\Models\Core\GraphNode::with('outgoingEdges', 'incomingEdges')->get();
            foreach ($nodes as $node) {
                $vertex = $graph->createVertex(['id' => $node->id, 'attributes' => json_decode($node->attributes, true)]);
                foreach ($node->outgoingEdges as $edge) {
                    $toVertex = $graph->getVertex($edge->to_node_id);
                    $graph->createEdgeDirected($vertex, $toVertex, ['type' => $edge->type, 'level' => $edge->level]);
                }
            }

            $start = $graph->getVertex($user->graphNode->id);
            $algo = new BreadthFirstSearch($start);
            $visited = $algo->getVertices();

            $result = [];
            foreach ($visited as $vertex) {
                $attrs = $vertex->getAttribute('attributes');
                if ($attribute) {
                    $result = array_merge($result, $attrs[$attribute] ?? []);
                } else if ($type && $vertex->hasEdgesOutWithAttribute('type', $type)) {
                    $result[] = $vertex->getId();
                }
            }

            return array_unique($result);
        });
    }
}
///////End-of-File : GraphTraversalTrait.php

File : HasAuditFields.php
/////////Content of file HasAuditFields.php
<?php

namespace App\Models\Traits;

use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * Trait HasAuditFields
 * 
 * Adds automatic tracking of who created, updated, and deleted records
 * 
 * @property int|null $created_by
 * @property int|null $updated_by
 * @property int|null $deleted_by
 */
trait HasAuditFields
{
    protected static function bootHasAuditFields(): void
    {
        // Automatically set created_by and updated_by on creation
        static::creating(function ($model) {
            if (auth()->check() && !$model->created_by) {
                $model->created_by = auth()->id();
            }

            if (auth()->check() && !$model->updated_by) {
                $model->updated_by = auth()->id();
            }
        });

        // Automatically set updated_by on update
        static::updating(function ($model) {
            if (auth()->check() && !$model->isDirty('updated_by')) {
                $model->updated_by = auth()->id();
            }
        });

        // Automatically set deleted_by on soft delete
        static::deleting(function ($model) {
            if (method_exists($model, 'isForceDeleting') && !$model->isForceDeleting()) {
                if (auth()->check() && !$model->deleted_by) {
                    $model->deleted_by = auth()->id();
                    $model->saveQuietly(); // Save without triggering events
                }
            }
        });
    }


    /**
     * Get the user who created this record
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(config('auth.providers.users.model'), 'created_by');
    }

    /**
     * Get the user who last updated this record
     */
    public function updater(): BelongsTo
    {
        return $this->belongsTo(config('auth.providers.users.model'), 'updated_by');
    }

    /**
     * Get the user who deleted this record
     */
    public function deleter(): BelongsTo
    {
        return $this->belongsTo(config('auth.providers.users.model'), 'deleted_by');
    }

    /**
     * Scope to filter by creator
     */
    public function scopeCreatedBy($query, $userId)
    {
        return $query->where('created_by', $userId);
    }

    /**
     * Scope to filter by updater
     */
    public function scopeUpdatedBy($query, $userId)
    {
        return $query->where('updated_by', $userId);
    }

    /**
     * Scope to filter by deleter
     */
    public function scopeDeletedBy($query, $userId)
    {
        return $query->where('deleted_by', $userId);
    }
}
///////End-of-File : HasAuditFields.php

File : HasColumnTransformations.php
/////////Content of file HasColumnTransformations.php
<?php

namespace App\Models\Traits;

/**
 * Trait HasColumnTransformations
 * 
 * Automatically transform column values during create/update
 * 
 * Usage in Model:
 * 
 * use HasColumnTransformations;
 * 
 * protected $columnTransformations = [
 *     'code' => 'uppercase_alphanumeric_dash',
 *     'slug' => 'lowercase_alphanumeric_dash',
 *     'name' => 'title_case',
 *     'email' => 'lowercase',
 *     'custom_field' => ['regex' => '/[^A-Z0-9]/', 'replacement' => '']
 * ];
 */
trait HasColumnTransformations
{
    protected static function bootHasColumnTransformations(): void
    {
        // Apply transformations before creating
        static::creating(function ($model) {
            $model->applyColumnTransformations();
        });

        // Apply transformations before updating
        static::updating(function ($model) {
            $model->applyColumnTransformations();
        });
    }

    /**
     * Apply all column transformations
     */
    protected function applyColumnTransformations(): void
    {
        if (empty($this->columnTransformations)) {
            return;
        }

        foreach ($this->columnTransformations as $column => $transformation) {
            if ($this->isFillable($column) && $this->{$column} !== null) {
                $this->{$column} = $this->transformValue($this->{$column}, $transformation);
            }
        }
    }

    /**
     * Transform a value based on transformation type
     */
    protected function transformValue($value, $transformation)
    {
        // Handle array-based custom transformations
        if (is_array($transformation)) {
            return $this->applyCustomTransformation($value, $transformation);
        }

        // Handle string-based predefined transformations
        return match ($transformation) {
            // Uppercase transformations
            'uppercase' => strtoupper($value),
            'uppercase_alphanumeric' => $this->uppercaseAlphanumeric($value),
            'uppercase_alphanumeric_dash' => $this->uppercaseAlphanumericDash($value),
            'uppercase_alphanumeric_underscore' => $this->uppercaseAlphanumericUnderscore($value),
            'uppercase_alphanumeric_dash_underscore' => $this->uppercaseAlphanumericDashUnderscore($value),

            // Lowercase transformations
            'lowercase' => strtolower($value),
            'lowercase_alphanumeric' => $this->lowercaseAlphanumeric($value),
            'lowercase_alphanumeric_dash' => $this->lowercaseAlphanumericDash($value),
            'lowercase_alphanumeric_underscore' => $this->lowercaseAlphanumericUnderscore($value),
            'lowercase_alphanumeric_dash_underscore' => $this->lowercaseAlphanumericDashUnderscore($value),
            'lowercase_alphanumeric_dash_dot' => $this->lowercaseAlphanumericDashDot($value),

            // Title/Sentence case
            'title_case' => $this->titleCase($value),
            'sentence_case' => $this->sentenceCase($value),
            'capitalize_first' => ucfirst($value),

            // Alphanumeric only
            'alphanumeric' => $this->alphanumeric($value),
            'numeric' => $this->numeric($value),
            'alpha' => $this->alpha($value),

            // Special formats
            // 'slug' => \Illuminate\Support\Str::slug($value),
            'snake_case' => $this->snakeCase($value),
            'kebab_case' => $this->kebabCase($value),
            'camel_case' => $this->camelCase($value),
            'pascal_case' => $this->pascalCase($value),

            // Trimming
            'trim' => trim($value),
            'trim_spaces' => $this->trimSpaces($value),

            default => $value,
        };
    }

    /**
     * Apply custom regex-based transformation
     */
    protected function applyCustomTransformation($value, array $config)
    {
        if (isset($config['regex']) && isset($config['replacement'])) {
            return preg_replace($config['regex'], $config['replacement'], $value);
        }

        if (isset($config['callback']) && is_callable($config['callback'])) {
            return call_user_func($config['callback'], $value);
        }

        return $value;
    }

    // UPPERCASE TRANSFORMATIONS
    protected function uppercaseAlphanumeric($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9]/', '', $value);
        return strtoupper($cleaned);
    }

    protected function uppercaseAlphanumericDash($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9\-]/', '', $value);
        return strtoupper($cleaned);
    }

    protected function uppercaseAlphanumericUnderscore($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9_]/', '', $value);
        return strtoupper($cleaned);
    }

    protected function uppercaseAlphanumericDashUnderscore($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9\-_]/', '', $value);
        return strtoupper($cleaned);
    }

    // LOWERCASE TRANSFORMATIONS
    protected function lowercaseAlphanumeric($value): string
    {
        return strtolower(preg_replace('/[^A-Za-z0-9]/', '', $value));
    }

    protected function lowercaseAlphanumericDash($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9\-]/', '', $value);
        $cleaned = preg_replace('/-+/', '-', $cleaned);
        return strtolower(trim($cleaned, '-'));
    }

    protected function lowercaseAlphanumericUnderscore($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9_]/', '', $value);
        $cleaned = preg_replace('/_+/', '_', $cleaned);
        return strtolower(trim($cleaned, '_'));
    }

    protected function lowercaseAlphanumericDashUnderscore($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9\-_]/', '', $value);
        return strtolower($cleaned);
    }

    protected function lowercaseAlphanumericDashDot($value): string
    {
        $cleaned = preg_replace('/[^A-Za-z0-9\-\.]/', '', $value);
        return strtolower($cleaned);
    }

    // CASE TRANSFORMATIONS
    protected function titleCase($value): string
    {
        return mb_convert_case($value, MB_CASE_TITLE, 'UTF-8');
    }

    protected function sentenceCase($value): string
    {
        return ucfirst(strtolower($value));
    }

    // ALPHANUMERIC TRANSFORMATIONS
    protected function alphanumeric($value): string
    {
        return preg_replace('/[^A-Za-z0-9]/', '', $value);
    }

    protected function numeric($value): string
    {
        return preg_replace('/[^0-9]/', '', $value);
    }

    protected function alpha($value): string
    {
        return preg_replace('/[^A-Za-z]/', '', $value);
    }

    // SPECIAL FORMATS
    protected function slug($value): string
    {
        // return \Illuminate\Support\Str::slug($value);
    }

    protected function snakeCase($value): string
    {
        return \Illuminate\Support\Str::snake($value);
    }

    protected function kebabCase($value): string
    {
        return \Illuminate\Support\Str::kebab($value);
    }

    protected function camelCase($value): string
    {
        return \Illuminate\Support\Str::camel($value);
    }

    protected function pascalCase($value): string
    {
        return \Illuminate\Support\Str::studly($value);
    }

    protected function trimSpaces($value): string
    {
        return preg_replace('/\s+/', ' ', trim($value));
    }
}
///////End-of-File : HasColumnTransformations.php

File : HasSlug.php
/////////Content of file HasSlug.php
<?php

namespace App\Models\Traits;

use Illuminate\Support\Str;

/**
 * Trait HasSlug
 * 
 * Automatically generates slug from specified field
 * 
 * @property string $slug
 */
trait HasSlug
{
    protected static function bootHasSlug(): void
    {
        static::creating(function ($model) {
            if (empty($model->slug)) {
                $model->slug = $model->generateSlug();
            }
        });

        static::updating(function ($model) {
            if ($model->isDirty($model->getSlugSourceField())) {
                $model->slug = $model->generateSlug();
            }
        });
    }

    /**
     * Generate a unique slug
     */
    protected function generateSlug(): string
    {
        $sourceField = $this->getSlugSourceField();
        $slug = Str::slug($this->{$sourceField});
        $originalSlug = $slug;
        $count = 1;

        // Ensure uniqueness
        while (static::where('slug', $slug)->where('id', '!=', $this->id ?? 0)->exists()) {
            $slug = $originalSlug . '-' . $count++;
        }

        return $slug;
    }

    /**
     * Get the field to generate slug from
     * Override this in your model if needed
     */
    protected function getSlugSourceField(): string
    {
        return property_exists($this, 'slugSourceField')
            ? $this->slugSourceField
            : 'name';
    }

    /**
     * Scope to find by slug
     */
    public function scopeSlug($query, string $slug)
    {
        return $query->where('slug', $slug);
    }

    /**
     * Get the route key for the model
     */
    public function getRouteKeyName(): string
    {
        return 'slug';
    }
}
///////End-of-File : HasSlug.php

File : HasTreeStructure.php
/////////Content of file HasTreeStructure.php
<?php

namespace App\Models\Traits;

use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

/**
 * Trait HasTreeStructure
 * 
 * Provides hierarchical tree functionality with materialized path
 * 
 * Required fields:
 * - parent_id (nullable foreign key to self)
 * - level (integer)
 * - path (text, stores '/1/5/12' format)
 * 
 * Usage:
 * use HasTreeStructure;
 * 
 * Auto-maintains:
 * - level (depth in tree)
 * - path (materialized path for fast queries)
 */
trait HasTreeStructure
{
    /**
     * Boot the trait
     */
    protected static function bootHasTreeStructure(): void
    {
        static::creating(function ($model) {
            $model->updateTreeFields();
        });

        static::updating(function ($model) {
            if ($model->isDirty('parent_id')) {
                $model->updateTreeFields();
                $model->updateDescendantsPath();
            }
        });
    }

    /**
     * Parent relationship
     */
    public function parent(): BelongsTo
    {
        return $this->belongsTo(static::class, 'parent_id');
    }

    /**
     * Children relationship
     */
    public function children(): HasMany
    {
        return $this->hasMany(static::class, 'parent_id');
    }

    /**
     * Update level and path
     */
    protected function updateTreeFields(): void
    {
        if ($this->parent_id) {
            $parent = static::find($this->parent_id);
            $this->level = $parent->level + 1;
            $this->path = $parent->path . '/' . $this->parent_id;
        } else {
            $this->level = 0;
            $this->path = '';
        }
    }

    /**
     * Update all descendants' paths
     */
    protected function updateDescendantsPath(): void
    {
        foreach ($this->children as $child) {
            $child->updateTreeFields();
            $child->saveQuietly();
            $child->updateDescendantsPath();
        }
    }

    /**
     * Get all ancestors
     */
    public function ancestors()
    {
        if (!$this->path) {
            return collect();
        }

        $ids = array_filter(explode('/', $this->path));

        return static::whereIn('id', $ids)->orderBy('level')->get();
    }

    /**
     * Get all descendants
     */
    public function descendants()
    {
        return static::where('path', 'like', $this->path . '/' . $this->id . '%')->get();
    }

    /**
     * Get siblings
     */
    public function siblings()
    {
        return static::where('parent_id', $this->parent_id)
            ->where('id', '!=', $this->id)
            ->get();
    }

    /**
     * Check if this is ancestor of another node
     */
    public function isAncestorOf($node): bool
    {
        return str_contains($node->path, '/' . $this->id . '/') ||
            str_ends_with($node->path, '/' . $this->id);
    }

    /**
     * Check if this is descendant of another node
     */
    public function isDescendantOf($node): bool
    {
        return str_contains($this->path, '/' . $node->id . '/') ||
            str_ends_with($this->path, '/' . $node->id);
    }

    /**
     * Get root nodes (level 0)
     */
    public function scopeRoots($query)
    {
        return $query->whereNull('parent_id')->orWhere('level', 0);
    }

    /**
     * Get tree structure as nested array
     */
    public static function tree()
    {
        $items = static::orderBy('sort_order')->get();

        return static::buildTree($items);
    }

    /**
     * Build nested tree structure
     */
    protected static function buildTree($items, $parentId = null)
    {
        $branch = [];

        foreach ($items as $item) {
            if ($item->parent_id == $parentId) {
                $children = static::buildTree($items, $item->id);

                if ($children) {
                    $item->children_tree = $children;
                }

                $branch[] = $item;
            }
        }

        return $branch;
    }

    /**
     * Get breadcrumb path
     */
    public function breadcrumb($separator = ' > ')
    {
        $ancestors = $this->ancestors();
        $ancestors->push($this);

        return $ancestors->pluck('name')->implode($separator);
    }

    /**
     * Scope: By level
     */
    public function scopeByLevel($query, int $level)
    {
        return $query->where('level', $level);
    }
}
///////End-of-File : HasTreeStructure.php

Folder : d:\xampp\htdocs\vdms\app\.\Providers

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Providers

File : a
/////////Content of file a
///////End-of-File : a

File : AppServiceProvider.php
/////////Content of file AppServiceProvider.php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     */
    public function register(): void
    {
        //
    }

    /**
     * Bootstrap any application services.
     */
    public function boot(): void
    {
        //
    }
}
///////End-of-File : AppServiceProvider.php

File : AuthServiceProvider.php
/////////Content of file AuthServiceProvider.php
<?php

namespace App\Providers;

use App\Models\User;
use App\Services\PermissionService;
use Illuminate\Auth\Notifications\ResetPassword;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Gate;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The model to policy mappings for the application.
     *
     * @var array<class-string, class-string>
     */
    protected $policies = [
        // 'App\Models\Model' => 'App\Policies\ModelPolicy',
    ];

    /**
     * Register any authentication / authorization services.
     *
     * This method is called by Laravel after all service providers are registered
     * and is the place to define all of your gates and policies!
     */
    public function boot(): void
    {
        ResetPassword::createUrlUsing(function (object $notifiable, string $token) {
            return config('app.url') . "/password-reset/$token?email=" . urlencode($notifiable->getEmailForPasswordReset());
        });

        // Define gates for permission checking
        $this->definePermissionGates();

        // Define gates for specific resources
        $this->defineResourceGates();

        // Define gates for data scoping
        $this->defineScopeGates();
    }

    /**
     * Define permission-based gates
     *
     * Gate::check() allows you to use:
     * if (Gate::check('branch.view')) { ... }
     * if (auth()->user()->can('branch.view')) { ... }
     * @can('branch.view') ... @endcan in Blade
     */
    private function definePermissionGates(): void
    {
        // Generic permission gate
        Gate::define('permission', function (User $user, string $permission) {
            return $user->can($permission);
        });

        // Super admin gate (bypasses everything)
        Gate::define('super-admin', function (User $user) {
            return $user->isSuperAdmin();
        });

        // Admin gate
        Gate::define('admin', function (User $user) {
            return $user->hasRole(['super_admin', 'admin']);
        });
    }

    /**
     * Define resource-specific gates
     * 
     * Usage:
     * if (Gate::check('create-branch')) { ... }
     * @can('create-branch') ... @endcan
     */
    private function defineResourceGates(): void
    {
        // Branch gates
        Gate::define('view-branches', function (User $user) {
            return $user->can('branch.view');
        });

        Gate::define('create-branch', function (User $user) {
            return $user->can('branch.create');
        });

        Gate::define('edit-branch', function (User $user) {
            return $user->can('branch.edit');
        });

        Gate::define('delete-branch', function (User $user) {
            return $user->can('branch.delete');
        });

        // Location gates
        Gate::define('view-locations', function (User $user) {
            return $user->can('location.view');
        });

        Gate::define('create-location', function (User $user) {
            return $user->can('location.create');
        });

        Gate::define('edit-location', function (User $user) {
            return $user->can('location.edit');
        });

        Gate::define('delete-location', function (User $user) {
            return $user->can('location.delete');
        });

        // Department gates
        Gate::define('view-departments', function (User $user) {
            return $user->can('department.view');
        });

        Gate::define('create-department', function (User $user) {
            return $user->can('department.create');
        });

        Gate::define('edit-department', function (User $user) {
            return $user->can('department.edit');
        });

        Gate::define('delete-department', function (User $user) {
            return $user->can('department.delete');
        });

        // Add more as needed for other resources
        // (vertical, segment, brand, etc.)
    }

    /**
     * Define data scope gates
     * 
     * These gates check if user can access specific data
     * Usage:
     * if (Gate::check('view-branch', $branch)) { ... }
     * @can('view-branch', $branch) ... @endcan
     */
    private function defineScopeGates(): void
    {
        // View specific branch
        Gate::define('view-branch', function (User $user, $branch) {
            // Super admin can view any branch
            if ($user->isSuperAdmin()) {
                return true;
            }

            // Check if user has general view permission
            if (!$user->can('branch.view')) {
                return false;
            }

            // Check if user has access to this specific branch
            return $user->hasAccessTo('branch', $branch->id);
        });

        // Edit specific branch
        Gate::define('edit-branch', function (User $user, $branch) {
            if ($user->isSuperAdmin()) {
                return true;
            }

            if (!$user->can('branch.edit')) {
                return false;
            }

            return $user->hasAccessTo('branch', $branch->id);
        });

        // Delete specific branch
        Gate::define('delete-branch', function (User $user, $branch) {
            if ($user->isSuperAdmin()) {
                return true;
            }

            if (!$user->can('branch.delete')) {
                return false;
            }

            return $user->hasAccessTo('branch', $branch->id);
        });

        // Similar gates for other resources
        Gate::define('view-location', function (User $user, $location) {
            if ($user->isSuperAdmin()) return true;
            if (!$user->can('location.view')) return false;
            return $user->hasAccessTo('location', $location->id);
        });

        Gate::define('edit-location', function (User $user, $location) {
            if ($user->isSuperAdmin()) return true;
            if (!$user->can('location.edit')) return false;
            return $user->hasAccessTo('location', $location->id);
        });

        Gate::define('delete-location', function (User $user, $location) {
            if ($user->isSuperAdmin()) return true;
            if (!$user->can('location.delete')) return false;
            return $user->hasAccessTo('location', $location->id);
        });

        Gate::define('view-department', function (User $user, $department) {
            if ($user->isSuperAdmin()) return true;
            if (!$user->can('department.view')) return false;
            return $user->hasAccessTo('department', $department->id);
        });

        Gate::define('edit-department', function (User $user, $department) {
            if ($user->isSuperAdmin()) return true;
            if (!$user->can('department.edit')) return false;
            return $user->hasAccessTo('department', $department->id);
        });

        Gate::define('delete-department', function (User $user, $department) {
            if ($user->isSuperAdmin()) return true;
            if (!$user->can('department.delete')) return false;
            return $user->hasAccessTo('department', $department->id);
        });
    }
}
///////End-of-File : AuthServiceProvider.php

File : KeywordValueServiceProvider.php
/////////Content of file KeywordValueServiceProvider.php
<?php

namespace App\Providers;

use App\Services\KeywordValueService;
use Illuminate\Support\ServiceProvider;

class KeywordValueServiceProvider extends ServiceProvider
{
    /**
     * Register the application services.
     */
    public function register(): void
    {
        // Register singleton instance
        $this->app->singleton('keyword-value', function ($app) {
            return new KeywordValueService();
        });

        // Alias for easier access (optional)
        $this->app->alias('keyword-value', KeywordValueService::class);
    }

    /**
     * Bootstrap the application services.
     */
    public function boot(): void
    {
        // Service is ready to use
    }
}
///////End-of-File : KeywordValueServiceProvider.php

Folder : d:\xampp\htdocs\vdms\app\.\Services

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Services

File : AuthenticationService.php
/////////Content of file AuthenticationService.php
<?php

namespace App\Services;

use App\Models\Core\OtpToken;
use App\Models\Core\DeviceSession;
use App\Models\Core\OtpAttemptLog;
use App\Models\Core\AccountLock;
use App\Models\User;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Cache;
use App\Exceptions\ValidationException;
use App\Exceptions\PermissionException;

class AuthenticationService
{
    const OTP_LENGTH = 6;
    const MAX_OTP_ATTEMPTS = 3;
    const ACCOUNT_LOCK_MINUTES = 30;
    const RATE_LIMIT_WINDOW = 10;
    const RATE_LIMIT_MAX = 3;

    /**
     * Request OTP for login
     */
    public function requestOtp(string $mobile): array
    {
        try {
            $mobile = $this->validateAndFormatMobile($mobile);

            $user = User::where('phone', $mobile)->first(); // Assume 'phone' is mobile field
            if (!$user) {
                return $this->errorResponse('Mobile not registered', 'E002', 404);
            }

            if ($this->isAccountLocked($user)) {
                return $this->errorResponse('Account locked. Contact admin', 'E004', 403);
            }

            if ($this->exceededRateLimit($mobile)) {
                return $this->errorResponse('Too many OTP requests. Try again later', 'E005', 429);
            }

            $otp = $this->generateOtp();
            $expiresAt = now()->addMinutes(10);

            OtpToken::create([
                'user_id' => $user->id,
                'otp_hash' => Hash::make($otp),
                'mobile' => $mobile,
                'expires_at' => $expiresAt,
                'created_by' => $user->id, // Audit
            ]);

            // Log attempt
            OtpAttemptLog::create([
                'user_id' => $user->id,
                'mobile' => $mobile,
                'action' => 'request',
                'ip_address' => request()->ip(),
                'user_agent' => request()->userAgent(),
                'created_by' => $user->id,
            ]);

            // TODO: Send OTP via SMS/Email (integrate provider)

            return ['success' => true, 'data' => ['otp' => $otp, 'expires_at' => $expiresAt]]; // In prod, don't return OTP
        } catch (\Exception $e) {
            return $this->errorResponse($e->getMessage(), 'E500', 500);
        }
    }

    /**
     * Verify OTP and bind device
     */
    public function verifyOtp(array $data): array
    {
        try {
            $mobile = $this->validateAndFormatMobile($data['mobile']);

            $user = User::where('phone', $mobile)->first();
            if (!$user) {
                return $this->errorResponse('Mobile not registered', 'E002', 404);
            }

            $otpToken = OtpToken::where('user_id', $user->id)->where('mobile', $mobile)->latest()->first();
            if (!$otpToken || $otpToken->expires_at < now()) {
                return $this->errorResponse('OTP expired or invalid', 'E002', 401);
            }

            if (!Hash::check($data['otp'], $otpToken->otp_hash)) {
                $this->logFailedAttempt($user, $mobile, 'Invalid OTP');
                if ($this->failedAttemptsExceeded($mobile)) {
                    $this->lockAccount($user, 'Too many failed attempts');
                    return $this->errorResponse('Account locked due to failed attempts', 'E004', 403);
                }
                return $this->errorResponse('Invalid OTP', 'E002', 401);
            }

            // Bind device
            DeviceSession::create([
                'user_id' => $user->id,
                'device_id' => $data['device_id'],
                'device_name' => $data['device_name'],
                'platform' => $data['platform'],
                'last_active_at' => now(),
                'created_by' => $user->id,
            ]);

            // Create Sanctum token with device ability
            $token = $user->createToken('api-token', ['device_id' => $data['device_id']]);

            // Log success
            OtpAttemptLog::create([
                'user_id' => $user->id,
                'mobile' => $mobile,
                'action' => 'verify',
                'ip_address' => request()->ip(),
                'user_agent' => request()->userAgent(),
                'created_by' => $user->id,
            ]);

            // Delete used OTP
            $otpToken->delete();

            return ['success' => true, 'data' => ['token' => $token->plainTextToken, 'user' => $user]];
        } catch (\Exception $e) {
            return $this->errorResponse($e->getMessage(), 'E500', 500);
        }
    }

    /**
     * Get current user info
     */
    public function me(User $user): array
    {
        return ['success' => true, 'data' => $user];
    }

    /**
     * Logout and revoke token
     */
    public function logout(User $user): array
    {
        $user->currentAccessToken()->delete();
        return ['success' => true];
    }

    // Helper methods (adapt from reference)
    private function validateAndFormatMobile(string $mobile): string
    {
        if (!preg_match('/^\d{10}$/', $mobile)) {
            throw new ValidationException('Invalid mobile number format');
        }
        return $mobile;
    }

    private function generateOtp(): string
    {
        return str_pad(rand(0, 999999), self::OTP_LENGTH, '0', STR_PAD_LEFT);
    }

    private function isAccountLocked(User $user): bool
    {
        $lock = AccountLock::where('user_id', $user->id)->where('locked_until', '>', now())->first();
        return (bool) $lock;
    }

    private function exceededRateLimit(string $mobile): bool
    {
        $key = 'otp_rate:' . $mobile;
        $attempts = Cache::get($key, 0);
        if ($attempts >= self::RATE_LIMIT_MAX) {
            return true;
        }
        Cache::put($key, $attempts + 1, self::RATE_LIMIT_WINDOW * 60);
        return false;
    }

    private function logFailedAttempt(User $user, string $mobile, string $reason): void
    {
        OtpAttemptLog::create([
            'user_id' => $user->id,
            'mobile' => $mobile,
            'action' => 'verify_failed',
            'ip_address' => request()->ip(),
            'user_agent' => request()->userAgent(),
            'reason' => $reason,
            'created_by' => $user->id,
        ]);
    }

    private function failedAttemptsExceeded(string $mobile): bool
    {
        $count = OtpAttemptLog::where('mobile', $mobile)
            ->where('action', 'verify_failed')
            ->where('created_at', '>', now()->subMinutes(15))
            ->count();
        return $count >= self::MAX_OTP_ATTEMPTS;
    }

    private function lockAccount(User $user, string $reason): void
    {
        AccountLock::create([
            'user_id' => $user->id,
            'locked_until' => now()->addMinutes(self::ACCOUNT_LOCK_MINUTES),
            'reason' => $reason,
            'created_by' => $user->id,
        ]);
    }

    private function errorResponse(string $message, string $code, int $status): array
    {
        return ['success' => false, 'error' => ['message' => $message, 'code' => $code, 'http_status' => $status]];
    }
}
///////End-of-File : AuthenticationService.php

File : d
/////////Content of file d
///////End-of-File : d

File : KeywordValueService.php
/////////Content of file KeywordValueService.php
<?php

namespace App\Services;

use App\Models\Core\Keyvalue;
use App\Models\Core\KeywordMaster;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Log;

/**
 * KeywordValueService - Centralized service for Keyword/Keyvalue lookups
 * 
 * Handles all interactions with the Keyword-Value mechanism
 * - Get value IDs by keyword + key
 * - Get value objects
 * - Get all values for a keyword
 * - Caching for performance
 * - Error handling and logging
 */
class KeywordValueService
{
    private const CACHE_TTL = 3600; // 1 hour
    private const CACHE_PREFIX = 'kwv_';

    /**
     * Get Keyvalue ID by keyword and key
     * 
     * Usage: KeywordValueService::getValueId('fuel_type', 'diesel')
     * Returns: Integer ID or null
     * 
     * @param string $keyword The keyword name (e.g., 'fuel_type', 'body_type')
     * @param string $key The value key (e.g., 'diesel', 'petrol')
     * @param bool $activeOnly Only search active records
     * @return int|null
     */
    public static function getValueId(string $keyword, string $key, bool $activeOnly = true): ?int
    {
        try {
            $cacheKey = self::CACHE_PREFIX . "id_{$keyword}_{$key}";

            // Try to get from cache
            $cached = Cache::get($cacheKey);
            if ($cached !== null) {
                return $cached;
            }

            // Get KeywordMaster first
            $master = KeywordMaster::where('keyword', $keyword)->first();
            if (!$master) {
                Log::warning("KeywordMaster not found for keyword: {$keyword}");
                return null;
            }

            // Query Keyvalue with proper relationship
            $query = Keyvalue::where('keyword_master_id', $master->id)
                ->where('key', $key);

            if ($activeOnly) {
                $query->where('status', 1);
            }

            $result = $query->value('id');

            // Cache the result (even if null, to avoid repeated queries)
            Cache::put($cacheKey, $result, self::CACHE_TTL);

            return $result;
        } catch (\Exception $e) {
            Log::error("KeywordValueService::getValueId error", [
                'keyword' => $keyword,
                'key' => $key,
                'error' => $e->getMessage(),
            ]);
            return null;
        }
    }

    /**
     * Get Keyvalue object by keyword and key
     * 
     * Usage: KeywordValueService::getValue('fuel_type', 'diesel')
     * Returns: Keyvalue model instance or null
     * 
     * @param string $keyword
     * @param string $key
     * @param bool $activeOnly
     * @return Keyvalue|null
     */
    public static function getValue(string $keyword, string $key, bool $activeOnly = true): ?Keyvalue
    {
        try {
            $master = KeywordMaster::where('keyword', $keyword)->first();
            if (!$master) {
                return null;
            }

            $query = Keyvalue::where('keyword_master_id', $master->id)
                ->where('key', $key);

            if ($activeOnly) {
                $query->where('status', 1);
            }

            return $query->first();
        } catch (\Exception $e) {
            Log::error("KeywordValueService::getValue error", [
                'keyword' => $keyword,
                'key' => $key,
                'error' => $e->getMessage(),
            ]);
            return null;
        }
    }

    /**
     * Get all values for a keyword
     * 
     * Usage: KeywordValueService::getValues('fuel_type')
     * Returns: ['diesel' => 1, 'petrol' => 2, ...]
     * 
     * @param string $keyword
     * @param bool $activeOnly
     * @return array Key-value pairs: ['key' => id, ...]
     */
    public static function getValues(string $keyword, bool $activeOnly = true): array
    {
        try {
            $cacheKey = self::CACHE_PREFIX . "values_{$keyword}";

            // Try to get from cache
            $cached = Cache::get($cacheKey);
            if ($cached !== null) {
                return $cached;
            }

            $master = KeywordMaster::where('keyword', $keyword)->first();
            if (!$master) {
                return [];
            }

            $query = Keyvalue::where('keyword_master_id', $master->id);

            if ($activeOnly) {
                $query->where('status', 1);
            }

            $result = $query->pluck('id', 'key')->toArray();

            // Cache the result
            Cache::put($cacheKey, $result, self::CACHE_TTL);

            return $result;
        } catch (\Exception $e) {
            Log::error("KeywordValueService::getValues error", [
                'keyword' => $keyword,
                'error' => $e->getMessage(),
            ]);
            return [];
        }
    }

    /**
     * Get all value objects for a keyword with their data
     * 
     * Usage: KeywordValueService::getValueObjects('body_type')
     * Returns: Collection of Keyvalue models
     * 
     * @param string $keyword
     * @param bool $activeOnly
     * @param bool $recursive Include child values
     * @return \Illuminate\Database\Eloquent\Collection
     */
    public static function getValueObjects(string $keyword, bool $activeOnly = true, bool $recursive = false)
    {
        try {
            $master = KeywordMaster::where('keyword', $keyword)->first();
            if (!$master) {
                return collect();
            }

            $query = Keyvalue::where('keyword_master_id', $master->id);

            if ($activeOnly) {
                $query->where('status', 1);
            }

            if ($recursive) {
                $query->with('children');
                $query->whereNull('parent_id');
            }

            return $query->get();
        } catch (\Exception $e) {
            Log::error("KeywordValueService::getValueObjects error", [
                'keyword' => $keyword,
                'error' => $e->getMessage(),
            ]);
            return collect();
        }
    }

    /**
     * Get KeywordMaster ID by keyword
     * 
     * Usage: KeywordValueService::getKeywordId('fuel_type')
     * Returns: Integer ID or null
     * 
     * @param string $keyword
     * @return int|null
     */
    public static function getKeywordId(string $keyword): ?int
    {
        try {
            $cacheKey = self::CACHE_PREFIX . "keyword_{$keyword}";

            $cached = Cache::get($cacheKey);
            if ($cached !== null) {
                return $cached;
            }

            $result = KeywordMaster::where('keyword', $keyword)->value('id');

            Cache::put($cacheKey, $result, self::CACHE_TTL);

            return $result;
        } catch (\Exception $e) {
            Log::error("KeywordValueService::getKeywordId error", [
                'keyword' => $keyword,
                'error' => $e->getMessage(),
            ]);
            return null;
        }
    }

    /**
     * Get value by keyword and value property (instead of key)
     * 
     * Usage: KeywordValueService::getValueByValue('fuel_type', 'Diesel')
     * Returns: Keyvalue model or null
     * Note: This searches by 'value' column, not 'key'
     * 
     * @param string $keyword
     * @param string $value The value to search for
     * @param bool $activeOnly
     * @return Keyvalue|null
     */
    public static function getValueByValue(string $keyword, string $value, bool $activeOnly = true): ?Keyvalue
    {
        try {
            $master = KeywordMaster::where('keyword', $keyword)->first();
            if (!$master) {
                return null;
            }

            $query = Keyvalue::where('keyword_master_id', $master->id)
                ->where('value', $value);

            if ($activeOnly) {
                $query->where('status', 1);
            }

            return $query->first();
        } catch (\Exception $e) {
            Log::error("KeywordValueService::getValueByValue error", [
                'keyword' => $keyword,
                'value' => $value,
                'error' => $e->getMessage(),
            ]);
            return null;
        }
    }

    /**
     * Check if a keyword exists
     * 
     * @param string $keyword
     * @return bool
     */
    public static function keywordExists(string $keyword): bool
    {
        try {
            return KeywordMaster::where('keyword', $keyword)->exists();
        } catch (\Exception $e) {
            Log::error("KeywordValueService::keywordExists error", [
                'keyword' => $keyword,
                'error' => $e->getMessage(),
            ]);
            return false;
        }
    }

    /**
     * Check if a value exists for a keyword
     * 
     * @param string $keyword
     * @param string $key
     * @param bool $activeOnly
     * @return bool
     */
    public static function valueExists(string $keyword, string $key, bool $activeOnly = true): bool
    {
        try {
            $master = KeywordMaster::where('keyword', $keyword)->first();
            if (!$master) {
                return false;
            }

            $query = Keyvalue::where('keyword_master_id', $master->id)
                ->where('key', $key);

            if ($activeOnly) {
                $query->where('status', 1);
            }

            return $query->exists();
        } catch (\Exception $e) {
            Log::error("KeywordValueService::valueExists error", [
                'keyword' => $keyword,
                'key' => $key,
                'error' => $e->getMessage(),
            ]);
            return false;
        }
    }

    /**
     * Get enum array for select dropdowns
     * 
     * Usage: KeywordValueService::getEnum('fuel_type')
     * Returns: ['diesel' => 'Diesel', 'petrol' => 'Petrol', ...]
     * 
     * @param string $keyword
     * @param bool $activeOnly
     * @return array
     */
    public static function getEnum(string $keyword, bool $activeOnly = true): array
    {
        try {
            $cacheKey = self::CACHE_PREFIX . "enum_{$keyword}";

            $cached = Cache::get($cacheKey);
            if ($cached !== null) {
                return $cached;
            }

            $master = KeywordMaster::where('keyword', $keyword)->first();
            if (!$master) {
                return [];
            }

            $query = Keyvalue::where('keyword_master_id', $master->id);

            if ($activeOnly) {
                $query->where('status', 1);
            }

            $result = $query->pluck('value', 'key')->toArray();

            Cache::put($cacheKey, $result, self::CACHE_TTL);

            return $result;
        } catch (\Exception $e) {
            Log::error("KeywordValueService::getEnum error", [
                'keyword' => $keyword,
                'error' => $e->getMessage(),
            ]);
            return [];
        }
    }

    /**
     * Clear all caches for a specific keyword
     * 
     * @param string|null $keyword If null, clears all caches
     * @return void
     */
    public static function clearCache(?string $keyword = null): void
    {
        if ($keyword === null) {
            // Clear all kwv_ prefixed caches
            Cache::flush();
            Log::info("KeywordValueService: Cleared all caches");
        } else {
            // Clear specific keyword caches
            Cache::forget(self::CACHE_PREFIX . "id_{$keyword}");
            Cache::forget(self::CACHE_PREFIX . "values_{$keyword}");
            Cache::forget(self::CACHE_PREFIX . "enum_{$keyword}");
            Cache::forget(self::CACHE_PREFIX . "keyword_{$keyword}");
            Log::info("KeywordValueService: Cleared caches for keyword: {$keyword}");
        }
    }

    /**
     * Get value ID with fallback to value search
     * First tries by key, then by value property
     * 
     * Usage: KeywordValueService::findValueId('fuel_type', 'Diesel')
     * 
     * @param string $keyword
     * @param string $searchTerm Can be key or value
     * @param bool $activeOnly
     * @return int|null
     */
    public static function findValueId(string $keyword, string $searchTerm, bool $activeOnly = true): ?int
    {
        // Try by key first
        $id = self::getValueId($keyword, $searchTerm, $activeOnly);
        if ($id !== null) {
            return $id;
        }

        // Try by value
        $value = self::getValueByValue($keyword, $searchTerm, $activeOnly);
        return $value?->id;
    }
}
///////End-of-File : KeywordValueService.php

File : RulesUserImportTemplateGenerator.php
/////////Content of file RulesUserImportTemplateGenerator.php
<?php

namespace App\Services;

use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Style\Alignment;
use PhpOffice\PhpSpreadsheet\Style\Border;
use PhpOffice\PhpSpreadsheet\Style\Color;
use PhpOffice\PhpSpreadsheet\Style\Fill;
use PhpOffice\PhpSpreadsheet\Style\Font;
use PhpOffice\PhpSpreadsheet\Writer\Xlsx;

class RulesUserImportTemplateGenerator
{
    /**
     * Generate the Rules User Import Template
     */
    public static function generate($outputPath = null)
    {
        if (!$outputPath) {
            $outputPath = storage_path('templates/rules_user_import_template.xlsx');
        }

        // Create directory if it doesn't exist
        @mkdir(dirname($outputPath), 0755, true);

        $spreadsheet = new Spreadsheet();
        $sheet = $spreadsheet->getActiveSheet();
        $sheet->setTitle('User List');

        // Define headers (17 columns)
        $headers = [
            'S.No',
            'Name',
            'Email',
            'Mobile',
            'Mile ID',
            'Emp Code',
            'Designation',
            'Department',
            'Sub Department',
            'Location',
            'Branch',
            'Vertical',
            'Segment',
            'Sub Segment',
            'Models',
            'User ID',
            'Password',
        ];

        // Write headers
        foreach ($headers as $col => $header) {
            $cell = $sheet->getCellByColumnAndRow($col + 1, 1);
            $cell->setValue($header);

            // Create Font object for header
            $headerFont = new Font();
            $headerFont->setBold(true);
            $headerFont->setColor(new Color('FFFFFFFF'));
            $headerFont->setSize(11);

            // Set header style
            $cell->getStyle()->setFont($headerFont);
            $cell->getStyle()->setFill(new Fill([
                'fillType' => Fill::FILL_SOLID,
                'startColor' => new Color('FF366092'),
            ]));
            $cell->getStyle()->setAlignment(new Alignment([
                'horizontal' => Alignment::HORIZONTAL_CENTER,
                'vertical' => Alignment::VERTICAL_CENTER,
                'wrapText' => true,
            ]));
        }

        // Add sample data row
        $sampleData = [
            1,                              // S.No
            'ADNAN QURESHI',               // Name
            'adnan.qureshi@bmpl.com',      // Email (optional)
            '9876543210',                   // Mobile (optional)
            'MILE001',                      // Mile ID (optional)
            'BMPL - 006',                   // Emp Code (REQUIRED)
            'SALES CONSULTANT',             // Designation (REQUIRED)
            'SALES',                        // Department (REQUIRED)
            'SALES-BIKES',                  // Sub Department (optional, NULL = all divisions)
            'RATANGARH',                    // Location (optional)
            'CHURU',                        // Branch (optional, can be comma-separated: BIKANER, CHURU)
            'NEW CAR',                      // Vertical (optional, can be comma-separated)
            'LMM',                          // Segment (optional, can be comma-separated)
            'SEDAN',                        // Sub Segment (optional, NULL = all subsegments)
            'MODEL123',                     // Models (optional, can be comma-separated)
            'ADNAN006',                     // User ID (optional, generated if blank)
            '',                             // Password (optional, generated if blank)
        ];

        foreach ($sampleData as $col => $value) {
            $cell = $sheet->getCellByColumnAndRow($col + 1, 2);
            $cell->setValue($value);

            // Light gray background for sample row
            $cell->getStyle()->setFill(new Fill([
                'fillType' => Fill::FILL_SOLID,
                'startColor' => new Color('FFE7E6E6'),
            ]));
            $cell->getStyle()->setAlignment(new Alignment([
                'horizontal' => Alignment::HORIZONTAL_LEFT,
                'vertical' => Alignment::VERTICAL_CENTER,
            ]));
        }

        // Add instructions sheet
        $instructions = $spreadsheet->createSheet();
        $instructions->setTitle('Instructions');

        $instructionText = [
            ['RULES USER IMPORT - INSTRUCTIONS', ''],
            ['', ''],
            ['FIELD DESCRIPTIONS', ''],
            ['', ''],
            ['S.No', 'Row number (auto-generated, can be left blank)'],
            ['Name', 'Full name (e.g., "ADNAN QURESHI") - Will be split into First + Last Name'],
            ['Email', 'Email address - OPTIONAL. If blank, auto-generated as firstname.empcode@bmpl.com'],
            ['Mobile', 'Mobile number - OPTIONAL. If blank, auto-generated from sequence (9811122001, 9811122002, etc.)'],
            ['Mile ID', 'Milestone ID - Optional lookup field'],
            ['Emp Code', 'Employee Code - REQUIRED. Must be unique (e.g., "BMPL - 006")'],
            ['Designation', 'Job designation - REQUIRED. Must exist in system'],
            ['Department', 'Department - REQUIRED. Must exist in system'],
            ['Sub Department', 'Division/Sub Department - OPTIONAL. If blank, user has access to ALL divisions of the department'],
            ['Location', 'Office location - OPTIONAL. Can be comma-separated (e.g., "LOC1, LOC2")'],
            ['Branch', 'Branch - OPTIONAL. Can be comma-separated (e.g., "BIKANER, CHURU")'],
            ['Vertical', 'Vertical (NEW CAR, USED CAR) - OPTIONAL. Can be comma-separated'],
            ['Segment', 'Segment (PERSONAL, COMMERCIAL, LMM) - OPTIONAL. Can be comma-separated'],
            ['Sub Segment', 'Sub Segment - OPTIONAL. If blank, user has access to ALL sub segments of segment'],
            ['Models', 'Vehicle Models - OPTIONAL. Can be comma-separated'],
            ['User ID', 'Login username - OPTIONAL. If blank, auto-generated from Emp Code (BMPL006)'],
            ['Password', 'Login password - OPTIONAL. If blank, auto-generated as user@bmpl#EMPCODE'],
            ['', ''],
            ['IMPORTANT RULES', ''],
            ['', ''],
            ['1. Comma-Separated Values', 'Fields can contain comma-separated values for multiple assignments:'],
            ['', '  Branch: "BIKANER, CHURU" â†’ Creates 2 branch assignments'],
            ['', '  Vertical: "NEW CAR, USED CAR" â†’ Creates 2 vertical assignments'],
            ['', '  Department, Location, Segment, Sub Segment, Models also support this'],
            ['', ''],
            ['2. NULL Scoping (Hierarchical Wildcard)', 'When a child entity is NULL, user gets access to ALL children:'],
            ['', '  Department: ADMIN, Sub Department: NULL â†’ Access ALL divisions under ADMIN'],
            ['', '  Branch: BIKANER, Location: NULL â†’ Access ALL locations under BIKANER'],
            ['', '  Segment: PERSONAL, Sub Segment: NULL â†’ Access ALL sub segments under PERSONAL'],
            ['', ''],
            ['3. Re-importing Existing Users', 'If Emp Code already exists:'],
            ['', '  - Old assignments are DELETED'],
            ['', '  - New assignments are CREATED from the latest import'],
            ['', '  - Use this to update user roles/permissions'],
            ['', ''],
            ['4. Auto-Generated Fields', 'If left blank, these are auto-generated:'],
            ['', '  Email: firstname.empcode@bmpl.com (slugified)'],
            ['', '  Mobile: Sequential from 9811122001'],
            ['', '  User ID: Emp code with spaces/hyphens removed'],
            ['', '  Password: user@bmpl#EMPCODE (hashed with bcrypt)'],
        ];

        $row = 1;
        foreach ($instructionText as $instructionRow) {
            $cell1 = $instructions->getCellByColumnAndRow(1, $row);
            $cell2 = $instructions->getCellByColumnAndRow(2, $row);

            $cell1->setValue($instructionRow[0] ?? '');
            $cell2->setValue($instructionRow[1] ?? '');

            // Bold for section headers
            if (strpos($instructionRow[0], ':', 0) === false && !empty($instructionRow[0])) {
                if (in_array($instructionRow[0], ['FIELD DESCRIPTIONS', 'IMPORTANT RULES', 'RULES USER IMPORT - INSTRUCTIONS'])) {
                    $sectionFont = new Font();
                    $sectionFont->setBold(true);
                    $sectionFont->setSize(12);

                    if ($instructionRow[0] === 'RULES USER IMPORT - INSTRUCTIONS') {
                        $sectionFont->setSize(14);
                        $sectionFont->setColor(new Color('FFFFFFFF'));

                        $cell1->getStyle()->setFont($sectionFont);
                        $cell1->getStyle()->setFill(new Fill([
                            'fillType' => Fill::FILL_SOLID,
                            'startColor' => new Color('FF366092'),
                        ]));
                    } else {
                        $cell1->getStyle()->setFont($sectionFont);
                    }
                }
            }

            $row++;
        }

        // Set column widths
        $sheet->getColumnDimensionByColumn(1)->setWidth(8);   // S.No
        $sheet->getColumnDimensionByColumn(2)->setWidth(20);  // Name
        $sheet->getColumnDimensionByColumn(3)->setWidth(25);  // Email
        $sheet->getColumnDimensionByColumn(4)->setWidth(15);  // Mobile
        $sheet->getColumnDimensionByColumn(5)->setWidth(12);  // Mile ID
        $sheet->getColumnDimensionByColumn(6)->setWidth(15);  // Emp Code
        $sheet->getColumnDimensionByColumn(7)->setWidth(20);  // Designation
        $sheet->getColumnDimensionByColumn(8)->setWidth(15);  // Department
        $sheet->getColumnDimensionByColumn(9)->setWidth(18);  // Sub Department
        $sheet->getColumnDimensionByColumn(10)->setWidth(15); // Location
        $sheet->getColumnDimensionByColumn(11)->setWidth(25); // Branch
        $sheet->getColumnDimensionByColumn(12)->setWidth(20); // Vertical
        $sheet->getColumnDimensionByColumn(13)->setWidth(20); // Segment
        $sheet->getColumnDimensionByColumn(14)->setWidth(18); // Sub Segment
        $sheet->getColumnDimensionByColumn(15)->setWidth(20); // Models
        $sheet->getColumnDimensionByColumn(16)->setWidth(15); // User ID
        $sheet->getColumnDimensionByColumn(17)->setWidth(20); // Password

        $instructions->getColumnDimensionByColumn(1)->setWidth(25);
        $instructions->getColumnDimensionByColumn(2)->setWidth(60);

        // Save file
        $writer = new Xlsx($spreadsheet);
        $writer->save($outputPath);

        return $outputPath;
    }
}
///////End-of-File : RulesUserImportTemplateGenerator.php

Folder : d:\xampp\htdocs\vdms\app\.\Services\Importers

-------------Begin file-----------------
Listing of Folder d:\xampp\htdocs\vdms\app\.\Services\Importers

File : RulesUserImporter.php
/////////Content of file RulesUserImporter.php
<?php

namespace App\Services\Importers;

use Illuminate\Support\Facades\DB;
use App\Models\Core\Branch;
use App\Models\Core\Location;
use App\Models\Core\Department;
use App\Models\Core\Division;
use App\Models\Core\Vertical;
use App\Models\Core\Segment;
use App\Models\Core\SubSegment;
use App\Models\Core\VehicleModel;
use App\Models\Core\Designation;
use App\Models\Core\Person;
use App\Models\Core\Employee;
use App\Models\User;
use App\Models\UserDataScope;
use PhpOffice\PhpSpreadsheet\IOFactory;
use Illuminate\Support\Str;
use Exception;

class RulesUserImporter
{
    private $filePath;
    private $sheetName = 'Rules';
    private $startRow = 2;
    private $imported = 0;
    private $updated = 0;
    private $skipped = 0;
    private $errors = [];
    private $warnings = [];
    private $existingUsers = [];
    private $importedUserIds = [];
    private $mobileSequence = 9000000001;

    public function __construct($filePath = null, $sheetName = null)
    {
        $this->filePath = $filePath;

        if ($sheetName) {
            $this->sheetName = $sheetName;
        }

        // Pre-load existing users for update detection by User.code (NOT Emp Code)
        $this->existingUsers = User::pluck('id', 'code')->toArray();
    }

    /**
     * Execute the import process
     */
    public function execute()
    {
        $startTime = microtime(true);

        try {
            $spreadsheet = IOFactory::load($this->filePath);

            // Check if sheet exists
            if (!$spreadsheet->sheetNameExists($this->sheetName)) {
                return $this->formatResult(false, "Sheet '{$this->sheetName}' not found");
            }

            $worksheet = $spreadsheet->getSheetByName($this->sheetName);
            $maxRow = $worksheet->getHighestRow();

            DB::beginTransaction();

            // Process each row
            for ($row = $this->startRow; $row <= $maxRow; $row++) {
                try {
                    $data = $this->extractRowData($worksheet, $row);

                    if (empty($data['Emp Code'])) {
                        $this->skipped++;
                        continue;
                    }

                    $this->processUserRow($data, $row);
                } catch (Exception $e) {
                    $this->errors[] = [
                        'row' => $row,
                        'error' => $e->getMessage(),
                    ];
                    $this->skipped++;
                }
            }

            DB::commit();
            $duration = round(microtime(true) - $startTime, 2);

            return $this->formatResult(
                true,
                "Import completed successfully. Imported: {$this->imported}, Updated: {$this->updated}, Skipped: {$this->skipped}",
                $duration
            );
        } catch (Exception $e) {
            DB::rollBack();
            return $this->formatResult(false, "Import failed: " . $e->getMessage());
        }
    }

    /**
     * Extract data from a single row
     */
    private function extractRowData($worksheet, $row)
    {
        return [
            'S.No' => $worksheet->getCell("A{$row}")->getValue(),
            'Name' => $worksheet->getCell("B{$row}")->getValue(),
            'Email' => $worksheet->getCell("C{$row}")->getValue(),
            'Mobile' => $worksheet->getCell("D{$row}")->getValue(),
            'Mile ID' => $worksheet->getCell("E{$row}")->getValue(),
            'Emp Code' => $worksheet->getCell("F{$row}")->getValue(),
            'Designation' => $worksheet->getCell("G{$row}")->getValue(),
            'Department' => $worksheet->getCell("H{$row}")->getValue(),
            'Sub Department' => $worksheet->getCell("I{$row}")->getValue(),
            'Location' => $worksheet->getCell("J{$row}")->getValue(),
            'Branch' => $worksheet->getCell("K{$row}")->getValue(),
            'Vertical' => $worksheet->getCell("L{$row}")->getValue(),
            'Segment' => $worksheet->getCell("M{$row}")->getValue(),
            'Sub Segment' => $worksheet->getCell("N{$row}")->getValue(),
            'Models' => $worksheet->getCell("O{$row}")->getValue(),
            'User ID' => $worksheet->getCell("P{$row}")->getValue(),
            'Password' => $worksheet->getCell("Q{$row}")->getValue(),
        ];
    }

    /**
     * Process a complete user row
     * âœ… FIXED: Now correctly detects existing users by User.code instead of Emp Code
     */
    private function processUserRow($data, $row)
    {
        // Parse name
        $nameParts = $this->parseName($data['Name']);
        $firstName = $nameParts['first_name'];
        $lastName = $nameParts['last_name'];

        // Generate/get email
        $email = $this->generateEmail($data['Email'], $firstName, $data['Emp Code']);

        // Generate/get mobile
        $mobile = $this->generateMobile($data['Mobile']);

        // Get or create Person
        $person = $this->getOrCreatePerson([
            'first_name' => $firstName,
            'last_name' => $lastName,
            'email_primary' => $email,
            'mobile_primary' => $mobile,
        ]);

        // Lookup required entities
        $designation = $this->lookupDesignation($data['Designation']);
        $department = $this->lookupDepartment($data['Department']);

        if (!$designation || !$department) {
            throw new Exception("Designation or Department not found");
        }

        // Get or create Employee
        $employee = $this->getOrCreateEmployee([
            'person_id' => $person->id,
            'code' => $data['Emp Code'],
            'designation_id' => $designation->id,
            'primary_department_id' => $department->id,
            'joining_date' => now()->toDateString(),
        ]);

        // âœ… FIXED: Generate userId FIRST, then check if user exists by User.code
        $userId = $data['User ID'] ?? $this->generateUserId($data['Emp Code']);
        $isNewUser = !isset($this->existingUsers[$userId]);

        // âœ… FIXED: Only generate password for new users (don't overwrite on update)
        $password = $isNewUser ? $this->generatePassword($data['Password'] ?? $data['Emp Code']) : null;

        // Get or create User
        $user = $this->getOrCreateUser([
            'person_id' => $person->id,
            'employee_id' => $employee->id,
            'code' => $userId,
            'email' => $email,
            'password' => $password,
            'name' => "{$firstName} {$lastName}",
            'mobile' => $mobile,  // âœ… FIXED: Now passing mobile to method
        ]);

        // Track imported user
        $this->importedUserIds[] = $user->id;

        if ($isNewUser) {
            $this->imported++;
        } else {
            $this->updated++;
        }

        // Clear old assignments if updating
        if (!$isNewUser) {
            $employee->branches()->detach();
            $employee->departments()->detach();
            $employee->locations()->detach();
            $employee->divisions()->detach();
            $employee->verticals()->detach();
            $employee->posts()->detach();
            $user->userDataScopes()->delete();
        }

        // Process multi-value assignments
        $this->processAssignments($employee, $user, $data);
    }

    /**
     * Process all assignments for user
     */
    private function processAssignments($employee, $user, $data)
    {
        // Branch assignments (with Location scoping)
        $branches = $this->parseMultiValue($data['Branch']);
        foreach ($branches as $branchCode) {
            $branch = Branch::where('code', $branchCode)->first();
            if ($branch) {
                $employee->branches()->attach($branch->id, [
                    'from_date' => now(),
                    'is_primary' => count($branches) === 1,
                    'is_current' => true,
                ]);

                // Create data scope for branch (NULL location = all locations)
                $location = $this->lookupLocation($data['Location']);
                $this->createDataScope($user, 'branch', $location ? null : $branch->id, 'branch');
            }
        }

        // Location assignments if specified
        if (!empty($data['Location'])) {
            $locations = $this->parseMultiValue($data['Location']);
            foreach ($locations as $locationCode) {
                $location = Location::where('code', $locationCode)->first();
                if ($location) {
                    $employee->locations()->attach($location->id, [
                        'from_date' => now(),
                        'is_current' => true,
                    ]);

                    // Create data scope for location
                    $this->createDataScope($user, 'location', $location->id);
                }
            }
        }

        // Department assignments (with Division scoping)
        $departments = $this->parseMultiValue($data['Department']);
        foreach ($departments as $deptCode) {
            $dept = Department::where('code', $deptCode)->first();
            if ($dept) {
                $employee->departments()->attach($dept->id, [
                    'from_date' => now(),
                    'is_current' => true,
                ]);

                // Create data scope for department (NULL division = all divisions)
                $division = $this->lookupDivision($data['Sub Department']);
                $this->createDataScope($user, 'department', $division ? null : $dept->id, 'department');
            }
        }

        // Division (Sub Department) assignments if specified
        if (!empty($data['Sub Department'])) {
            $divisions = $this->parseMultiValue($data['Sub Department']);
            foreach ($divisions as $divCode) {
                $division = Division::where('code', $divCode)->first();
                if ($division) {
                    $employee->divisions()->attach($division->id, [
                        'from_date' => now(),
                        'is_current' => true,
                    ]);

                    // Create data scope for division
                    $this->createDataScope($user, 'division', $division->id);
                }
            }
        }

        // Vertical assignments
        if (!empty($data['Vertical'])) {
            $verticals = $this->parseMultiValue($data['Vertical']);
            foreach ($verticals as $vertCode) {
                $vertical = Vertical::where('code', $vertCode)->first();
                if ($vertical) {
                    $employee->verticals()->attach($vertical->id, [
                        'from_date' => now(),
                        'is_current' => true,
                    ]);
                    $this->createDataScope($user, 'vertical', $vertical->id);
                }
            }
        }

        // Brand/Segment/SubSegment/VehicleModel/Variant/Variant_Color hierarchy
        if (!empty($data['Segment'])) {
            $segments = $this->parseMultiValue($data['Segment']);
            foreach ($segments as $segCode) {
                $segment = Segment::where('code', $segCode)->first();
                if ($segment) {
                    $this->createDataScope($user, 'segment', $segment->id);

                    // If SubSegment specified, scope to that; else scope to all subsegments
                    if (!empty($data['Sub Segment'])) {
                        $subSegments = $this->parseMultiValue($data['Sub Segment']);
                        foreach ($subSegments as $subSegCode) {
                            $subSegment = SubSegment::where('code', $subSegCode)->first();
                            if ($subSegment) {
                                $this->createDataScope($user, 'subsegment', $subSegment->id);

                                // If Models specified, scope to those; else scope to all
                                if (!empty($data['Models'])) {
                                    $models = $this->parseMultiValue($data['Models']);
                                    foreach ($models as $modelCode) {
                                        $model = VehicleModel::where('code', $modelCode)->first();
                                        if ($model) {
                                            $this->createDataScope($user, 'vehiclemodel', $model->id);
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // If no SubSegment, scope to all vehicles under segment
                        $allModels = VehicleModel::whereHas('subSegment', function ($q) use ($segment) {
                            $q->where('segment_id', $segment->id);
                        })->get();

                        foreach ($allModels as $model) {
                            $this->createDataScope($user, 'vehiclemodel', $model->id);
                        }
                    }
                }
            }
        }
    }

    /**
     * Parse comma-separated values
     */
    private function parseMultiValue($value)
    {
        if (empty($value)) {
            return [];
        }

        return array_filter(
            array_map('trim', explode(',', $value)),
            fn($v) => !empty($v)
        );
    }

    /**
     * Parse name into first and last
     */
    private function parseName($name)
    {
        $parts = array_map('trim', explode(' ', trim($name), 2));

        return [
            'first_name' => $parts[0] ?? '',
            'last_name' => $parts[1] ?? $parts[0] ?? '',
        ];
    }

    /**
     * Generate email if missing
     */
    private function generateEmail($email, $firstName, $empCode)
    {
        if (!empty($email)) {
            return $email;
        }

        $slug = Str::slug("{$firstName}.{$empCode}", '.');

        return "{$slug}@bmpl.com";
    }

    /**
     * Generate mobile if missing
     */
    private function generateMobile($mobile)
    {
        if (!empty($mobile)) {
            return $mobile;
        }

        $generated = $this->mobileSequence;
        $this->mobileSequence++;

        return (string)$generated;
    }

    /**
     * Generate user ID from employee code
     */
    private function generateUserId($empCode)
    {
        return str_replace([' ', '-'], '', $empCode);
    }

    /**
     * Generate password
     */
    private function generatePassword($empCode)
    {
        $sanitized = str_replace([' ', '-', 'BMPL'], '', $empCode);

        return "user@bmpl#{$sanitized}";
    }

    /**
     * Get or create Person
     */
    private function getOrCreatePerson($data)
    {
        return Person::updateOrCreate(
            ['email_primary' => $data['email_primary']],
            [
                'first_name' => $data['first_name'],
                'last_name' => $data['last_name'],
                'mobile_primary' => $data['mobile_primary'],
                'display_name' => "{$data['first_name']} {$data['last_name']}",
            ]
        );
    }

    /**
     * Get or create Employee
     */
    private function getOrCreateEmployee($data)
    {
        return Employee::updateOrCreate(
            ['code' => $data['code']],
            [
                'person_id' => $data['person_id'],
                'designation_id' => $data['designation_id'],
                'primary_department_id' => $data['primary_department_id'],
                'joining_date' => $data['joining_date'],
                'is_active' => true,
            ]
        );
    }

    /**
     * Get or create User
     * âœ… FIXED: Only sets password on creation, never overwrites existing password on update
     * âœ… FIXED: Now includes mobile field in updateData
     */
    private function getOrCreateUser($data)
    {
        // Prepare update data - conditionally include password
        $updateData = [
            'person_id' => $data['person_id'],
            'employee_id' => $data['employee_id'],
            'email' => $data['email'],
            'name' => $data['name'],
            'mobile' => $data['mobile'] ?? null,  // âœ… FIXED: Save mobile field
            'is_active' => true,
        ];

        // Only include password if provided (new user only)
        if (!empty($data['password'])) {
            $updateData['password'] = bcrypt($data['password']);
        }

        return User::updateOrCreate(
            ['code' => $data['code']],
            $updateData
        );
    }

    /**
     * Create data scope for RBAC
     */
    private function createDataScope($user, $scopeType, $scopeValue, $contextType = null)
    {
        UserDataScope::create([
            'user_id' => $user->id,
            'scope_type' => $scopeType,
            'scope_value' => $scopeValue, // NULL means all children
            'status' => 'active',
        ]);
    }

    /**
     * Lookup helpers
     */
    private function lookupDesignation($code)
    {
        return Designation::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    private function lookupDepartment($code)
    {
        return Department::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    private function lookupDivision($code)
    {
        if (empty($code)) return null;

        return Division::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    private function lookupLocation($code)
    {
        if (empty($code)) return null;

        return Location::where('code', $code)
            ->orWhere('name', 'LIKE', "%{$code}%")
            ->first();
    }

    /**
     * Format result
     */
    private function formatResult($success, $message, $duration = 0)
    {
        return [
            'success' => $success,
            'imported' => $this->imported,
            'updated' => $this->updated,
            'skipped' => $this->skipped,
            'total_processed' => $this->imported + $this->updated + $this->skipped,
            'errors' => $this->errors,
            'warnings' => $this->warnings,
            'message' => $message,
            'duration_seconds' => $duration,
        ];
    }
}
///////End-of-File : RulesUserImporter.php

